/**
 * Git Branch Manager - Real implementation for safe development workflow
 * Creates feature branches, manages commits, and handles rollback scenarios
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { Logger } from '../utils/logger';

const execAsync = promisify(exec);

export interface GitStatus {
  branch: string;
  ahead: number;
  behind: number;
  modified: string[];
  untracked: string[];
  staged: string[];
}

export interface CommitResult {
  hash: string;
  message: string;
  filesChanged: number;
}

export class GitBranchManager {
  private logger = Logger.getInstance();
  private projectPath: string;

  constructor(projectPath: string = process.cwd()) {
    this.projectPath = projectPath;
  }

  /**
   * Create a new feature branch for safe development
   */
  async createFeatureBranch(workflowId: string, description: string): Promise<string> {
    try {
      // Sanitize branch name
      const sanitizedDescription = description
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);
      
      const branchName = `feature/${workflowId}-${sanitizedDescription}`;
      
      this.logger.info(`üåø Creating feature branch: ${branchName}`);

      // Ensure we're in a git repository
      await this.ensureGitRepo();

      // Stash any uncommitted changes
      await this.stashUncommittedChanges();

      // Checkout main/master branch and pull latest
      const mainBranch = await this.getMainBranch();
      await execAsync(`git checkout ${mainBranch}`, { cwd: this.projectPath });
      
      try {
        await execAsync(`git pull origin ${mainBranch}`, { cwd: this.projectPath });
      } catch (error) {
        this.logger.warn('‚ö†Ô∏è Could not pull latest changes (no remote or network issue)');
      }

      // Create and checkout feature branch
      await execAsync(`git checkout -b ${branchName}`, { cwd: this.projectPath });

      this.logger.info(`‚úÖ Feature branch created: ${branchName}`);
      return branchName;

    } catch (error) {
      this.logger.error(`‚ùå Failed to create feature branch: ${error.message}`);
      throw new Error(`Git branch creation failed: ${error.message}`);
    }
  }

  /**
   * Commit changes with descriptive message
   */
  async commitChanges(message: string, files?: string[]): Promise<CommitResult> {
    try {
      this.logger.info(`üìù Committing changes: ${message}`);

      // Add specific files or all changes
      if (files && files.length > 0) {
        for (const file of files) {
          await execAsync(`git add "${file}"`, { cwd: this.projectPath });
        }
      } else {
        await execAsync('git add .', { cwd: this.projectPath });
      }

      // Create commit
      const commitMessage = `${message}\n\nü§ñ Generated by CodeMind Workflow\nCo-authored-by: CodeMind <codemind@ai>`;
      await execAsync(`git commit -m "${commitMessage}"`, { cwd: this.projectPath });

      // Get commit details
      const { stdout: hashOutput } = await execAsync('git rev-parse HEAD', { cwd: this.projectPath });
      const hash = hashOutput.trim().substring(0, 7);

      const { stdout: statsOutput } = await execAsync('git diff --stat HEAD~1', { cwd: this.projectPath });
      const filesChanged = (statsOutput.match(/\d+ files? changed/)?.[0].match(/\d+/)?.[0]) || '0';

      this.logger.info(`‚úÖ Committed changes: ${hash} (${filesChanged} files)`);

      return {
        hash,
        message,
        filesChanged: parseInt(filesChanged)
      };

    } catch (error) {
      this.logger.error(`‚ùå Failed to commit changes: ${error.message}`);
      throw new Error(`Git commit failed: ${error.message}`);
    }
  }

  /**
   * Commit and merge feature branch to main if quality checks pass
   */
  async commitAndMerge(branchName: string, finalMessage: string): Promise<void> {
    try {
      this.logger.info(`üîÄ Merging branch ${branchName} to main`);

      // Final commit on feature branch
      await this.commitChanges(finalMessage);

      // Switch to main branch
      const mainBranch = await this.getMainBranch();
      await execAsync(`git checkout ${mainBranch}`, { cwd: this.projectPath });

      // Merge feature branch (no-ff to preserve history)
      await execAsync(`git merge --no-ff ${branchName} -m "Merge ${branchName}: ${finalMessage}"`, { 
        cwd: this.projectPath 
      });

      // Clean up feature branch
      await execAsync(`git branch -d ${branchName}`, { cwd: this.projectPath });

      this.logger.info(`‚úÖ Successfully merged and cleaned up ${branchName}`);

    } catch (error) {
      this.logger.error(`‚ùå Failed to merge branch: ${error.message}`);
      throw new Error(`Git merge failed: ${error.message}`);
    }
  }

  /**
   * Rollback branch if quality checks fail
   */
  async rollbackBranch(branchName: string): Promise<void> {
    try {
      this.logger.info(`üîÑ Rolling back branch: ${branchName}`);

      // Switch to main branch
      const mainBranch = await this.getMainBranch();
      await execAsync(`git checkout ${mainBranch}`, { cwd: this.projectPath });

      // Force delete feature branch (lose all changes)
      await execAsync(`git branch -D ${branchName}`, { cwd: this.projectPath });

      // Restore any stashed changes
      try {
        await execAsync('git stash pop', { cwd: this.projectPath });
      } catch (error) {
        // No stash to pop, that's fine
      }

      this.logger.info(`‚úÖ Rolled back and cleaned up ${branchName}`);

    } catch (error) {
      this.logger.error(`‚ùå Failed to rollback branch: ${error.message}`);
      throw new Error(`Git rollback failed: ${error.message}`);
    }
  }

  /**
   * Get current git status
   */
  async getGitStatus(): Promise<GitStatus> {
    try {
      const { stdout: branchOutput } = await execAsync('git branch --show-current', { cwd: this.projectPath });
      const branch = branchOutput.trim();

      const { stdout: statusOutput } = await execAsync('git status --porcelain', { cwd: this.projectPath });
      
      const modified: string[] = [];
      const untracked: string[] = [];
      const staged: string[] = [];

      statusOutput.split('\n').forEach(line => {
        if (!line) return;
        const status = line.substring(0, 2);
        const file = line.substring(3);

        if (status.includes('M')) modified.push(file);
        if (status.includes('?')) untracked.push(file);
        if (status[0] !== ' ' && status[0] !== '?') staged.push(file);
      });

      return {
        branch,
        ahead: 0, // Would implement with git log comparison
        behind: 0,
        modified,
        untracked,
        staged
      };

    } catch (error) {
      throw new Error(`Failed to get git status: ${error.message}`);
    }
  }

  // Helper methods

  private async ensureGitRepo(): Promise<void> {
    try {
      await execAsync('git status', { cwd: this.projectPath });
    } catch (error) {
      throw new Error('Not a git repository. Please initialize git first: git init');
    }
  }

  private async getMainBranch(): Promise<string> {
    try {
      // Try to detect main branch (main, master, develop)
      const { stdout } = await execAsync('git branch -r', { cwd: this.projectPath });
      
      if (stdout.includes('origin/main')) return 'main';
      if (stdout.includes('origin/master')) return 'master';
      if (stdout.includes('origin/develop')) return 'develop';
      
      // Fallback to local branches
      const { stdout: localBranches } = await execAsync('git branch', { cwd: this.projectPath });
      
      if (localBranches.includes('main')) return 'main';
      if (localBranches.includes('master')) return 'master';
      
      return 'master'; // Default fallback

    } catch (error) {
      return 'master'; // Fallback
    }
  }

  private async stashUncommittedChanges(): Promise<void> {
    try {
      const { stdout } = await execAsync('git status --porcelain', { cwd: this.projectPath });
      if (stdout.trim()) {
        await execAsync('git stash push -m "CodeMind workflow stash"', { cwd: this.projectPath });
        this.logger.info('üì¶ Stashed uncommitted changes');
      }
    } catch (error) {
      // Ignore stash errors, probably nothing to stash
    }
  }
}

export default GitBranchManager;