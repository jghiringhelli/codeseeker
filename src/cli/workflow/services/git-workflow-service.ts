/**
 * Git Workflow Service
 * SOLID Principles: Single Responsibility - Handle Git operations for workflow only
 */

import { Logger } from '../../../shared/logger';
import { GitBranchManager } from '../../../shared/managers/git-branch-manager';
import {
  IGitWorkflowService,
  QualityCheckResult,
  SubTaskResult,
  WorkflowResult
} from '../interfaces/index';

export class GitWorkflowService implements IGitWorkflowService {
  private logger = Logger.getInstance();
  private gitManager: GitBranchManager;

  constructor(gitManager?: GitBranchManager) {
    this.gitManager = gitManager || new GitBranchManager();
  }

  async createFeatureBranch(workflowId: string, description: string): Promise<string> {
    this.logger.info('ðŸŒ¿ Creating feature branch...');

    try {
      // Sanitize description for branch name
      const sanitizedDescription = description
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);

      const branchName = `codemind/${workflowId}/${sanitizedDescription}`;

      // Create and checkout the new branch
      await this.gitManager.createBranch(branchName);
      await this.gitManager.checkoutBranch(branchName);

      this.logger.info(`Created and switched to branch: ${branchName}`);
      return branchName;
    } catch (error) {
      this.logger.error('Failed to create feature branch:', error);
      // Fallback to working directly on current branch (risky but functional)
      return await this.gitManager.getCurrentBranch();
    }
  }

  async finalizeChanges(
    branch: string,
    quality: QualityCheckResult,
    results: SubTaskResult[],
    isReport: boolean
  ): Promise<WorkflowResult> {
    this.logger.info('ðŸ”š Finalizing changes...');

    const filesModified = this.extractModifiedFiles(results);

    try {
      // For reports, no actual code changes to commit
      if (isReport) {
        return this.createReportResult(branch, quality, filesModified);
      }

      // Check if quality passes threshold (configurable)
      const qualityThreshold = 70; // Can be made configurable
      const shouldMerge = quality.overallScore >= qualityThreshold && quality.compilation.success;

      if (shouldMerge) {
        return await this.commitAndMergeChanges(branch, quality, filesModified);
      } else {
        return await this.handleQualityFailure(branch, quality, filesModified);
      }
    } catch (error) {
      this.logger.error('Failed to finalize changes:', error);
      return this.createFailureResult(branch, quality, filesModified, error);
    }
  }

  async rollbackChanges(workflowId: string): Promise<void> {
    this.logger.info('â†©ï¸ Rolling back changes...');

    try {
      // Find branches related to this workflow
      const branches = await this.gitManager.listBranches();
      const workflowBranches = branches.filter(branch => branch.includes(workflowId));

      for (const branch of workflowBranches) {
        try {
          // Switch to main branch first
          await this.gitManager.checkoutBranch('main');
          // Delete the workflow branch
          await this.gitManager.deleteBranch(branch, true); // Force delete
          this.logger.info(`Deleted branch: ${branch}`);
        } catch (branchError) {
          this.logger.warn(`Could not delete branch ${branch}:`, branchError);
        }
      }

      // Reset any uncommitted changes
      await this.gitManager.resetHard();

      this.logger.info('Rollback completed');
    } catch (error) {
      this.logger.error('Rollback failed:', error);
      throw error;
    }
  }

  async commitChanges(branch: string, message: string, files: string[]): Promise<void> {
    this.logger.info('ðŸ’¾ Committing changes...');

    try {
      // Stage the specific files
      if (files.length > 0) {
        for (const file of files) {
          await this.gitManager.stageFile(file);
        }
      } else {
        // Stage all changes if no specific files
        await this.gitManager.stageAllChanges();
      }

      // Create commit with descriptive message
      const commitMessage = `${message}\n\nGenerated by CodeMind Workflow\nBranch: ${branch}\nFiles: ${files.join(', ')}`;
      await this.gitManager.commit(commitMessage);

      this.logger.info('Changes committed successfully');
    } catch (error) {
      this.logger.error('Failed to commit changes:', error);
      throw error;
    }
  }

  private extractModifiedFiles(results: SubTaskResult[]): string[] {
    const allFiles = new Set<string>();

    for (const result of results) {
      for (const file of result.filesModified) {
        allFiles.add(file);
      }
    }

    return Array.from(allFiles);
  }

  private createReportResult(
    branch: string,
    quality: QualityCheckResult,
    filesModified: string[]
  ): WorkflowResult {
    return {
      success: true,
      filesModified,
      qualityScore: quality.overallScore,
      gitBranch: branch,
      databases: {
        neo4j: { nodesCreated: 0, relationshipsCreated: 0 },
        redis: { filesUpdated: 0, hashesUpdated: 0 },
        postgres: { recordsUpdated: 0 }
      },
      summary: 'Report generated successfully - no code changes made'
    };
  }

  private async commitAndMergeChanges(
    branch: string,
    quality: QualityCheckResult,
    filesModified: string[]
  ): Promise<WorkflowResult> {
    try {
      // Commit changes
      await this.commitChanges(
        branch,
        'CodeMind workflow implementation - quality checks passed',
        filesModified
      );

      // Merge back to main branch
      const mainBranch = 'main'; // Could be configurable
      await this.gitManager.checkoutBranch(mainBranch);
      await this.gitManager.mergeBranch(branch);

      // Clean up feature branch
      await this.gitManager.deleteBranch(branch);

      return {
        success: true,
        filesModified,
        qualityScore: quality.overallScore,
        gitBranch: mainBranch,
        databases: {
          neo4j: { nodesCreated: 0, relationshipsCreated: 0 }, // Will be filled by database service
          redis: { filesUpdated: 0, hashesUpdated: 0 },
          postgres: { recordsUpdated: 0 }
        },
        summary: `Successfully implemented changes with quality score ${quality.overallScore}%`
      };
    } catch (error) {
      this.logger.error('Failed to commit and merge:', error);
      throw error;
    }
  }

  private async handleQualityFailure(
    branch: string,
    quality: QualityCheckResult,
    filesModified: string[]
  ): Promise<WorkflowResult> {
    // Keep the branch but don't merge
    await this.commitChanges(
      branch,
      `CodeMind workflow - quality issues found (score: ${quality.overallScore}%)`,
      filesModified
    );

    return {
      success: false,
      filesModified,
      qualityScore: quality.overallScore,
      gitBranch: branch,
      databases: {
        neo4j: { nodesCreated: 0, relationshipsCreated: 0 },
        redis: { filesUpdated: 0, hashesUpdated: 0 },
        postgres: { recordsUpdated: 0 }
      },
      summary: `Quality checks failed (score: ${quality.overallScore}%). Changes saved in branch: ${branch}`
    };
  }

  private createFailureResult(
    branch: string,
    quality: QualityCheckResult,
    filesModified: string[],
    error: any
  ): WorkflowResult {
    return {
      success: false,
      filesModified,
      qualityScore: quality.overallScore,
      gitBranch: branch,
      databases: {
        neo4j: { nodesCreated: 0, relationshipsCreated: 0 },
        redis: { filesUpdated: 0, hashesUpdated: 0 },
        postgres: { recordsUpdated: 0 }
      },
      summary: `Workflow failed: ${error.message}`
    };
  }

  // Additional utility methods
  async getBranchStatus(): Promise<{
    currentBranch: string;
    hasUncommittedChanges: boolean;
    aheadBy: number;
    behindBy: number;
  }> {
    try {
      const currentBranch = await this.gitManager.getCurrentBranch();
      const status = await this.gitManager.getStatus();

      return {
        currentBranch,
        hasUncommittedChanges: status.hasChanges,
        aheadBy: status.ahead || 0,
        behindBy: status.behind || 0
      };
    } catch (error) {
      this.logger.error('Failed to get branch status:', error);
      return {
        currentBranch: 'unknown',
        hasUncommittedChanges: false,
        aheadBy: 0,
        behindBy: 0
      };
    }
  }

  async ensureCleanWorkingDirectory(): Promise<void> {
    const status = await this.getBranchStatus();

    if (status.hasUncommittedChanges) {
      this.logger.warn('Working directory has uncommitted changes. Stashing...');
      await this.gitManager.stashChanges('CodeMind auto-stash before workflow');
    }
  }
}