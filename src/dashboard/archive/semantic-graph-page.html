<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeMind - Semantic Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
        }

        .nav {
            display: flex;
            gap: 1rem;
        }

        .nav a {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .nav a:hover, .nav a.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: calc(100vh - 80px);
            gap: 1rem;
            padding: 1rem;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 1rem;
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: #f0f0f0;
        }

        .search-box, .filter-select {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            margin-bottom: 0.5rem;
        }

        .search-box::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .graph-stats {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 5px;
            margin-bottom: 1rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-weight: bold;
            color: #4ade80;
        }

        .graph-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .graph-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .graph-svg:active {
            cursor: grabbing;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node:hover {
            stroke-width: 3px;
        }

        .node.code { fill: #3b82f6; }
        .node.documentation { fill: #10b981; }
        .node.businessconcept { fill: #f59e0b; }
        .node.uicomponent { fill: #ec4899; }
        .node.testcase { fill: #8b5cf6; }

        .link {
            stroke: rgba(255, 255, 255, 0.6);
            stroke-width: 2;
            fill: none;
        }

        .node-label {
            fill: white;
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem;
            border-radius: 5px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
        }

        .node-details {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 5px;
            margin-top: 1rem;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0.25rem;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>üß† CodeMind Semantic Graph</h1>
        <nav class="nav">
            <a href="/dashboard">Dashboard</a>
            <a href="/dashboard/planner-page.html">Planner</a>
            <a href="/dashboard/orchestrator-page.html">Orchestrator</a>
            <a href="/dashboard/semantic-graph-page.html" class="active">Semantic Graph</a>
        </nav>
    </header>

    <div class="main-container">
        <div class="controls-panel">
            <div class="control-section">
                <h3>üîç Search</h3>
                <input type="text" class="search-box" placeholder="Search nodes..." id="searchBox">
                <button class="btn" onclick="performSearch()">Search</button>
            </div>

            <div class="control-section">
                <h3>üîß Filters</h3>
                <select class="filter-select" id="nodeTypeFilter" onchange="applyFilters()">
                    <option value="">All Node Types</option>
                    <option value="Code">Code</option>
                    <option value="Documentation">Documentation</option>
                    <option value="BusinessConcept">Business Concept</option>
                    <option value="UIComponent">UI Component</option>
                    <option value="TestCase">Test Case</option>
                </select>
                
                <select class="filter-select" id="domainFilter" onchange="applyFilters()">
                    <option value="">All Domains</option>
                    <option value="frontend">Frontend</option>
                    <option value="backend">Backend</option>
                    <option value="security">Security</option>
                    <option value="testing">Testing</option>
                    <option value="documentation">Documentation</option>
                </select>
            </div>

            <div class="control-section">
                <h3>üìä Graph Stats</h3>
                <div class="graph-stats">
                    <div class="stat-item">
                        <span>Total Nodes:</span>
                        <span class="stat-value" id="totalNodes">-</span>
                    </div>
                    <div class="stat-item">
                        <span>Relationships:</span>
                        <span class="stat-value" id="totalRelationships">-</span>
                    </div>
                    <div class="stat-item">
                        <span>Visible Nodes:</span>
                        <span class="stat-value" id="visibleNodes">-</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>‚ö° Actions</h3>
                <button class="btn" onclick="refreshGraph()">üîÑ Refresh</button>
                <button class="btn" onclick="resetZoom()">üéØ Reset Zoom</button>
                <button class="btn" onclick="exportGraph()">üì§ Export</button>
            </div>

            <div id="nodeDetails" class="node-details" style="display: none;">
                <h3>Node Details</h3>
                <div id="nodeDetailsContent"></div>
            </div>
        </div>

        <div class="graph-container">
            <svg class="graph-svg" id="graphSvg"></svg>
            <div class="tooltip" id="tooltip" style="display: none;"></div>
            <div class="loading" id="loading">Loading semantic graph...</div>
        </div>
    </div>

    <script>
        // Graph visualization state
        let graphData = { nodes: [], links: [] };
        let filteredData = { nodes: [], links: [] };
        let simulation, svg, container, zoom;
        let selectedNode = null;

        // Initialize the graph
        document.addEventListener('DOMContentLoaded', function() {
            initializeGraph();
            loadGraphData();
        });

        function initializeGraph() {
            const svgElement = d3.select("#graphSvg");
            svg = svgElement;
            
            // Create zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (event) => {
                    container.attr("transform", event.transform);
                });
            
            svg.call(zoom);
            
            // Create container for graph elements
            container = svg.append("g");
            
            // Initialize simulation
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter())
                .force("collision", d3.forceCollide().radius(30));
        }

        async function loadGraphData() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                // Get graph statistics
                const statsResponse = await fetch('/api/semantic-graph/statistics');
                const stats = await statsResponse.json();
                
                updateStats(stats);
                
                // Load nodes with a reasonable limit for visualization
                const nodesResponse = await fetch('/api/semantic-graph/nodes?limit=100');
                const nodes = await nodesResponse.json();
                
                // Load relationships
                const linksResponse = await fetch('/api/semantic-graph/relationships?limit=200');
                const links = await linksResponse.json();
                
                graphData = {
                    nodes: nodes.map(node => ({
                        id: node.id,
                        name: node.properties.name || node.id,
                        type: node.labels[0]?.toLowerCase() || 'unknown',
                        properties: node.properties,
                        labels: node.labels
                    })),
                    links: links.map(link => ({
                        source: link.startNodeId,
                        target: link.endNodeId,
                        type: link.type,
                        properties: link.properties
                    }))
                };
                
                filteredData = { ...graphData };
                renderGraph();
                
            } catch (error) {
                console.error('Failed to load graph data:', error);
                document.getElementById('loading').innerHTML = 
                    '‚ùå Failed to load graph data. Make sure the semantic graph service is running.';
            }
        }

        function updateStats(stats) {
            document.getElementById('totalNodes').textContent = stats.total_nodes || 0;
            document.getElementById('totalRelationships').textContent = stats.total_relationships || 0;
            document.getElementById('visibleNodes').textContent = filteredData.nodes.length;
        }

        function renderGraph() {
            document.getElementById('loading').style.display = 'none';
            
            // Clear previous elements
            container.selectAll("*").remove();
            
            // Create links
            const link = container.append("g")
                .selectAll("line")
                .data(filteredData.links)
                .enter().append("line")
                .attr("class", "link")
                .attr("stroke-width", d => Math.sqrt(2));
            
            // Create nodes
            const node = container.append("g")
                .selectAll("circle")
                .data(filteredData.nodes)
                .enter().append("circle")
                .attr("class", d => `node ${d.type}`)
                .attr("r", 15)
                .on("click", showNodeDetails)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip)
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded));
            
            // Create labels
            const label = container.append("g")
                .selectAll("text")
                .data(filteredData.nodes)
                .enter().append("text")
                .attr("class", "node-label")
                .text(d => d.name.length > 15 ? d.name.substring(0, 12) + "..." : d.name);
            
            // Update simulation
            simulation.nodes(filteredData.nodes);
            simulation.force("link").links(filteredData.links);
            
            // Set up ticking
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y + 5);
            });
            
            // Restart simulation
            simulation.restart();
            
            // Update viewport
            updateViewport();
            updateStats({ total_nodes: graphData.nodes.length, total_relationships: graphData.links.length });
        }

        function updateViewport() {
            const bounds = container.node().getBBox();
            const parent = svg.node().getBoundingClientRect();
            const fullWidth = parent.width;
            const fullHeight = parent.height;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;
            
            if (width == 0 || height == 0) return;
            
            const scale = 0.8 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
            
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }

        function showNodeDetails(event, d) {
            selectedNode = d;
            const details = document.getElementById('nodeDetails');
            const content = document.getElementById('nodeDetailsContent');
            
            content.innerHTML = `
                <h4>${d.name}</h4>
                <p><strong>Type:</strong> ${d.labels.join(', ')}</p>
                <p><strong>ID:</strong> ${d.id}</p>
                ${d.properties.description ? `<p><strong>Description:</strong> ${d.properties.description}</p>` : ''}
                ${d.properties.domain ? `<p><strong>Domain:</strong> ${d.properties.domain}</p>` : ''}
                ${d.properties.path ? `<p><strong>Path:</strong> ${d.properties.path}</p>` : ''}
                <button class="btn" onclick="exploreNode('${d.id}')">üîç Explore</button>
                <button class="btn" onclick="analyzeImpact('${d.id}')">‚ö° Impact</button>
            `;
            
            details.style.display = 'block';
        }

        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `<strong>${d.name}</strong><br>Type: ${d.type}<br>Connections: ${filteredData.links.filter(l => l.source.id === d.id || l.target.id === d.id).length}`;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function performSearch() {
            const query = document.getElementById('searchBox').value.trim();
            if (!query) return;
            
            // Highlight matching nodes
            const matchingNodes = graphData.nodes.filter(node => 
                node.name.toLowerCase().includes(query.toLowerCase()) ||
                (node.properties.description && node.properties.description.toLowerCase().includes(query.toLowerCase()))
            );
            
            // Filter to show only matching nodes and their connections
            if (matchingNodes.length > 0) {
                const matchingIds = new Set(matchingNodes.map(n => n.id));
                const connectedLinks = graphData.links.filter(l => 
                    matchingIds.has(l.source.id || l.source) || matchingIds.has(l.target.id || l.target)
                );
                
                filteredData = {
                    nodes: matchingNodes,
                    links: connectedLinks
                };
                
                renderGraph();
            }
        }

        function applyFilters() {
            const nodeType = document.getElementById('nodeTypeFilter').value;
            const domain = document.getElementById('domainFilter').value;
            
            let nodes = graphData.nodes;
            
            if (nodeType) {
                nodes = nodes.filter(n => n.labels.includes(nodeType));
            }
            
            if (domain) {
                nodes = nodes.filter(n => n.properties.domain === domain);
            }
            
            const nodeIds = new Set(nodes.map(n => n.id));
            const links = graphData.links.filter(l => 
                nodeIds.has(l.source.id || l.source) && nodeIds.has(l.target.id || l.target)
            );
            
            filteredData = { nodes, links };
            renderGraph();
        }

        function refreshGraph() {
            loadGraphData();
        }

        function resetZoom() {
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity);
        }

        function exportGraph() {
            const data = JSON.stringify(filteredData, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'semantic-graph.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        async function exploreNode(nodeId) {
            try {
                const response = await fetch(`/api/semantic-graph/explore/${nodeId}`);
                const data = await response.json();
                
                // Show related nodes
                const relatedIds = new Set([nodeId, ...data.relatedNodes.map(n => n.id)]);
                const relatedNodes = graphData.nodes.filter(n => relatedIds.has(n.id));
                const relatedLinks = graphData.links.filter(l => 
                    relatedIds.has(l.source.id || l.source) && relatedIds.has(l.target.id || l.target)
                );
                
                filteredData = { nodes: relatedNodes, links: relatedLinks };
                renderGraph();
                
            } catch (error) {
                console.error('Failed to explore node:', error);
            }
        }

        async function analyzeImpact(nodeId) {
            try {
                const response = await fetch(`/api/semantic-graph/impact/${nodeId}`);
                const data = await response.json();
                
                alert(`Impact Analysis:\n` +
                      `Code Files: ${data.impact.codeFiles}\n` +
                      `Documentation: ${data.impact.documentation}\n` +
                      `Tests: ${data.impact.tests}\n` +
                      `UI Components: ${data.impact.uiComponents}\n` +
                      `Risk Level: ${data.riskLevel}`);
                
            } catch (error) {
                console.error('Failed to analyze impact:', error);
            }
        }

        // Drag functions
        function dragStarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        function dragEnded(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const svg = d3.select("#graphSvg");
            const container = svg.select("g");
            const bounds = container.node().getBBox();
            const parent = svg.node().getBoundingClientRect();
            
            simulation.force("center", d3.forceCenter(parent.width / 2, parent.height / 2));
            simulation.restart();
        });
    </script>
</body>
</html>