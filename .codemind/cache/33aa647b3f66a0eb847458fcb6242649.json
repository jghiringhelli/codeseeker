{
  "content": "#!/usr/bin/env node\r\n\r\n/**\r\n * CodeMind Master Database Initialization Script\r\n * \r\n * Consolidated script that combines all database initialization functionality:\r\n * - Tests all database connections\r\n * - Initializes PostgreSQL, MongoDB, Neo4j, Redis, and DuckDB\r\n * - Avoids duplicate indexes and collections\r\n * - Populates databases with foundation data\r\n * - Runs semantic graph analysis\r\n * - Provides comprehensive status reporting\r\n * - Includes tool autodiscovery and project analysis\r\n */\r\n\r\nconst { Pool } = require('pg');\r\nconst { MongoClient } = require('mongodb');\r\nconst neo4j = require('neo4j-driver');\r\nconst Redis = require('ioredis');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst chalk = require('chalk');\r\n\r\n// Import semantic graph and autodiscovery services\r\nlet SemanticGraphService, ToolAutodiscoveryService, EnhancedDocumentMapAnalyzer, Logger;\r\ntry {\r\n  ({ SemanticGraphService } = require('../dist/services/semantic-graph'));\r\n  ({ ToolAutodiscoveryService } = require('../dist/shared/tool-autodiscovery'));\r\n  ({ EnhancedDocumentMapAnalyzer } = require('../dist/features/documentation/enhanced-map-analyzer'));\r\n  ({ Logger } = require('../dist/shared/logger'));\r\n} catch (error) {\r\n  console.log(chalk.yellow('âš ï¸  Some advanced features unavailable (build first with: npm run build)'));\r\n}\r\n\r\n// Configuration\r\nconst config = {\r\n  postgres: {\r\n    host: process.env.DB_HOST || 'localhost',\r\n    port: process.env.DB_PORT || 5432,\r\n    database: process.env.DB_NAME || 'codemind',\r\n    user: process.env.DB_USER || 'codemind',\r\n    password: process.env.DB_PASSWORD || 'codemind123'\r\n  },\r\n  mongodb: {\r\n    uri: process.env.MONGO_URI || \r\n      `mongodb://${process.env.MONGO_USER || 'codemind'}:${process.env.MONGO_PASSWORD || 'codemind123'}@${process.env.MONGO_HOST || 'localhost'}:${process.env.MONGO_PORT || 27017}/${process.env.MONGO_DB || 'codemind'}?authSource=admin`\r\n  },\r\n  neo4j: {\r\n    uri: process.env.NEO4J_URI || 'bolt://localhost:7687',\r\n    user: process.env.NEO4J_USER || 'neo4j',\r\n    password: process.env.NEO4J_PASSWORD || 'codemind123'\r\n  },\r\n  redis: {\r\n    host: process.env.REDIS_HOST || 'localhost',\r\n    port: process.env.REDIS_PORT || 6379,\r\n    password: process.env.REDIS_PASSWORD || undefined\r\n  }\r\n};\r\n\r\n// Global status tracker\r\nconst initStatus = {\r\n  connections: {},\r\n  initialized: {},\r\n  populated: {},\r\n  analyzed: {},\r\n  errors: [],\r\n  stats: {},\r\n  startTime: Date.now(),\r\n  endTime: null\r\n};\r\n\r\n// Helper function for safe execution with error tracking\r\nasync function safeExecute(name, operation, required = false) {\r\n  try {\r\n    console.log(chalk.blue(`ðŸ”„ ${name}...`));\r\n    const result = await operation();\r\n    console.log(chalk.green(`âœ… ${name} completed`));\r\n    return result;\r\n  } catch (error) {\r\n    const errorMsg = `${name} failed: ${error.message}`;\r\n    initStatus.errors.push(errorMsg);\r\n    if (required) {\r\n      console.error(chalk.red(`âŒ ${errorMsg}`));\r\n      throw error;\r\n    } else {\r\n      console.warn(chalk.yellow(`âš ï¸  ${errorMsg}`));\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n// Test all database connections\r\nasync function testConnections() {\r\n  console.log(chalk.blue('\\\\nðŸ” Testing database connections...'));\r\n  \r\n  const results = {\r\n    postgres: false,\r\n    mongodb: false,\r\n    neo4j: false,\r\n    redis: false\r\n  };\r\n  \r\n  // Test PostgreSQL\r\n  try {\r\n    const pgClient = new Pool(config.postgres);\r\n    await pgClient.query('SELECT 1');\r\n    await pgClient.end();\r\n    results.postgres = true;\r\n    console.log(chalk.green('âœ… PostgreSQL connection successful'));\r\n  } catch (err) {\r\n    console.log(chalk.yellow(`âš ï¸  PostgreSQL connection failed: ${err.message}`));\r\n  }\r\n  \r\n  // Test MongoDB\r\n  try {\r\n    const client = new MongoClient(config.mongodb.uri);\r\n    await client.connect();\r\n    await client.db().admin().ping();\r\n    await client.close();\r\n    results.mongodb = true;\r\n    console.log(chalk.green('âœ… MongoDB connection successful'));\r\n  } catch (err) {\r\n    console.log(chalk.yellow(`âš ï¸  MongoDB connection failed: ${err.message}`));\r\n  }\r\n  \r\n  // Test Neo4j\r\n  try {\r\n    const driver = neo4j.driver(\r\n      config.neo4j.uri,\r\n      neo4j.auth.basic(config.neo4j.user, config.neo4j.password)\r\n    );\r\n    const session = driver.session();\r\n    await session.run('RETURN 1');\r\n    await session.close();\r\n    await driver.close();\r\n    results.neo4j = true;\r\n    console.log(chalk.green('âœ… Neo4j connection successful'));\r\n  } catch (err) {\r\n    console.log(chalk.yellow(`âš ï¸  Neo4j connection failed: ${err.message}`));\r\n  }\r\n  \r\n  // Test Redis\r\n  try {\r\n    const redis = new Redis(config.redis);\r\n    await redis.ping();\r\n    redis.disconnect();\r\n    results.redis = true;\r\n    console.log(chalk.green('âœ… Redis connection successful'));\r\n  } catch (err) {\r\n    console.log(chalk.yellow(`âš ï¸  Redis connection failed: ${err.message}`));\r\n  }\r\n  \r\n  initStatus.connections = results;\r\n  return results;\r\n}\r\n\r\n// Initialize PostgreSQL\r\nasync function initializePostgreSQL() {\r\n  const pgClient = new Pool(config.postgres);\r\n  \r\n  try {\r\n    // Read and execute schema file\r\n    const schemaPath = path.join(__dirname, '..', 'src', 'database', 'schema.postgres.sql');\r\n    const schema = await fs.readFile(schemaPath, 'utf-8');\r\n    \r\n    // Split by statements and execute, handling duplicates gracefully\r\n    const statements = schema.split(';').filter(s => s.trim());\r\n    for (const statement of statements) {\r\n      if (statement.trim()) {\r\n        try {\r\n          await pgClient.query(statement);\r\n        } catch (err) {\r\n          if (!err.message.includes('already exists')) {\r\n            throw err;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Insert foundation data (ignore duplicates)\r\n    await pgClient.query(`\r\n      INSERT INTO projects (id, project_name, project_path, status, languages, frameworks, project_type, created_at)\r\n      VALUES \r\n        ('00000000-0000-0000-0000-000000000000', 'Default', '/default', 'active', '{}', '{}', 'template', NOW())\r\n      ON CONFLICT (id) DO NOTHING;\r\n    `);\r\n    \r\n    // Get table count for stats\r\n    const result = await pgClient.query(\"SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public'\");\r\n    initStatus.stats.postgresqlTables = parseInt(result.rows[0].count);\r\n    \r\n    initStatus.initialized.postgresql = true;\r\n    initStatus.populated.postgresql = true;\r\n    \r\n  } finally {\r\n    await pgClient.end();\r\n  }\r\n}\r\n\r\n// Initialize MongoDB with duplicate handling\r\nasync function initializeMongoDB() {\r\n  const client = new MongoClient(config.mongodb.uri);\r\n  \r\n  try {\r\n    await client.connect();\r\n    const db = client.db('codemind');\r\n    \r\n    // Create collections (ignore if exists)\r\n    const collections = [\r\n      'tool_configs',\r\n      'analysis_results', \r\n      'project_intelligence',\r\n      'knowledge_repository',\r\n      'workflow_states',\r\n      'templates'\r\n    ];\r\n    \r\n    for (const collectionName of collections) {\r\n      try {\r\n        await db.createCollection(collectionName);\r\n      } catch (err) {\r\n        if (err.code !== 48) { // Collection already exists\r\n          throw err;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Create indexes with duplicate handling\r\n    const indexOperations = [\r\n      () => db.collection('tool_configs').createIndex({ projectId: 1, toolName: 1 }, { unique: true }),\r\n      () => db.collection('analysis_results').createIndex({ projectId: 1, toolName: 1, timestamp: -1 }),\r\n      () => db.collection('analysis_results').createIndex({ summary: 'text' }),\r\n      () => db.collection('project_intelligence').createIndex({ projectId: 1 }, { unique: true }),\r\n      () => db.collection('knowledge_repository').createIndex({ \r\n        title: 'text', \r\n        content: 'text', \r\n        searchableText: 'text' \r\n      }, { \r\n        weights: { \r\n          title: 10, \r\n          searchableText: 5, \r\n          content: 1 \r\n        } \r\n      })\r\n    ];\r\n    \r\n    for (const operation of indexOperations) {\r\n      try {\r\n        await operation();\r\n      } catch (err) {\r\n        if (err.code !== 85) { // Index already exists\r\n          throw err;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Insert foundation data (ignore duplicates)\r\n    const toolConfigs = db.collection('tool_configs');\r\n    try {\r\n      await toolConfigs.insertMany([\r\n        {\r\n          projectId: 'default',\r\n          toolName: 'semantic-search',\r\n          config: {\r\n            embeddingModel: 'text-embedding-ada-002',\r\n            chunkSize: 4000,\r\n            overlapSize: 200,\r\n            similarity: 'cosine',\r\n            cacheEnabled: true\r\n          },\r\n          version: '1.0.0',\r\n          updatedAt: new Date()\r\n        },\r\n        {\r\n          projectId: 'default',\r\n          toolName: 'solid-principles',\r\n          config: {\r\n            checkSRP: true,\r\n            checkOCP: true,\r\n            checkLSP: true,\r\n            checkISP: true,\r\n            checkDIP: true,\r\n            severityThreshold: 'medium'\r\n          },\r\n          version: '1.0.0',\r\n          updatedAt: new Date()\r\n        }\r\n      ]);\r\n    } catch (err) {\r\n      if (err.code !== 11000) throw err; // Ignore duplicate key errors\r\n    }\r\n    \r\n    // Get collection stats\r\n    const collections_list = await db.listCollections().toArray();\r\n    initStatus.stats.mongodbCollections = collections_list.length;\r\n    \r\n    initStatus.initialized.mongodb = true;\r\n    initStatus.populated.mongodb = true;\r\n    \r\n  } finally {\r\n    await client.close();\r\n  }\r\n}\r\n\r\n// Initialize Neo4j\r\nasync function initializeNeo4j() {\r\n  const driver = neo4j.driver(\r\n    config.neo4j.uri,\r\n    neo4j.auth.basic(config.neo4j.user, config.neo4j.password)\r\n  );\r\n  \r\n  try {\r\n    const session = driver.session();\r\n    \r\n    // Create constraints and indexes (ignore duplicates)\r\n    const queries = [\r\n      'CREATE CONSTRAINT project_id IF NOT EXISTS FOR (p:Project) REQUIRE p.id IS UNIQUE',\r\n      'CREATE CONSTRAINT file_path IF NOT EXISTS FOR (f:File) REQUIRE (f.projectId, f.path) IS UNIQUE',\r\n      'CREATE CONSTRAINT class_name IF NOT EXISTS FOR (c:Class) REQUIRE (c.projectId, c.name) IS UNIQUE',\r\n      'CREATE INDEX project_name IF NOT EXISTS FOR (p:Project) ON (p.name)',\r\n      'CREATE INDEX file_type IF NOT EXISTS FOR (f:File) ON (f.type)'\r\n    ];\r\n    \r\n    for (const query of queries) {\r\n      try {\r\n        await session.run(query);\r\n      } catch (err) {\r\n        if (!err.message.includes('already exists')) {\r\n          throw err;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Create foundation nodes\r\n    await session.run(`\r\n      MERGE (p:Project {id: 'default'})\r\n      SET p.name = 'Default Project',\r\n          p.createdAt = datetime(),\r\n          p.status = 'template'\r\n    `);\r\n    \r\n    // Get node stats\r\n    const result = await session.run('MATCH (n) RETURN count(n) as total');\r\n    initStatus.stats.neo4jNodes = result.records[0].get('total').toNumber();\r\n    \r\n    initStatus.initialized.neo4j = true;\r\n    initStatus.populated.neo4j = true;\r\n    \r\n    await session.close();\r\n  } finally {\r\n    await driver.close();\r\n  }\r\n}\r\n\r\n// Initialize Redis\r\nasync function initializeRedis() {\r\n  const redis = new Redis(config.redis);\r\n  \r\n  try {\r\n    // Set up key patterns and initial values\r\n    await redis.set('codemind:initialized', new Date().toISOString());\r\n    await redis.hset('codemind:config', {\r\n      version: '2.0.0',\r\n      initialized_at: new Date().toISOString()\r\n    });\r\n    \r\n    // Create initial queues\r\n    await redis.lpush('codemind:queue:analysis', JSON.stringify({\r\n      type: 'init',\r\n      timestamp: new Date().toISOString()\r\n    }));\r\n    await redis.ltrim('codemind:queue:analysis', 0, 0); // Keep only the init message\r\n    \r\n    // Set up pub/sub channels\r\n    await redis.publish('codemind:events', JSON.stringify({\r\n      event: 'system_initialized',\r\n      timestamp: new Date().toISOString()\r\n    }));\r\n    \r\n    // Get Redis info for stats\r\n    const info = await redis.info('keyspace');\r\n    initStatus.stats.redisKeys = info.match(/keys=(\\d+)/)?.[1] || 0;\r\n    \r\n    initStatus.initialized.redis = true;\r\n    initStatus.populated.redis = true;\r\n    \r\n  } finally {\r\n    redis.disconnect();\r\n  }\r\n}\r\n\r\n// Initialize DuckDB directories\r\nasync function initializeDuckDB() {\r\n  const dirs = [\r\n    path.join(process.cwd(), '.codemind'),\r\n    path.join(process.cwd(), '.codemind', 'analytics'),\r\n    path.join(process.cwd(), '.codemind', 'cache')\r\n  ];\r\n  \r\n  for (const dir of dirs) {\r\n    await fs.mkdir(dir, { recursive: true });\r\n  }\r\n  \r\n  initStatus.initialized.duckdb = true;\r\n  initStatus.stats.duckdbDirectories = dirs.length;\r\n}\r\n\r\n// Run semantic graph analysis\r\nasync function runSemanticAnalysis(projectPath, projectId) {\r\n  if (!SemanticGraphService || !EnhancedDocumentMapAnalyzer) {\r\n    console.log(chalk.yellow('âš ï¸  Semantic analysis skipped (services not available)'));\r\n    return null;\r\n  }\r\n  \r\n  const semanticGraph = new SemanticGraphService();\r\n  await semanticGraph.initialize();\r\n  \r\n  // Enhanced document analysis\r\n  const analyzer = new EnhancedDocumentMapAnalyzer();\r\n  const analysisParams = {\r\n    projectPath: projectPath,\r\n    includeCodeAnalysis: true,\r\n    maxDepth: 3,\r\n    fileTypes: ['.ts', '.js', '.md', '.json']\r\n  };\r\n  \r\n  const result = await analyzer.analyzeDocumentationWithSemantics(analysisParams);\r\n  \r\n  // Get final statistics\r\n  const stats = await semanticGraph.getGraphStatistics();\r\n  \r\n  initStatus.analyzed.semanticGraph = true;\r\n  initStatus.stats.semanticGraphNodes = stats.total_nodes;\r\n  initStatus.stats.semanticGraphRelationships = stats.total_relationships;\r\n  \r\n  return { result, stats };\r\n}\r\n\r\n// Run tool autodiscovery and project analysis\r\nasync function runToolAutodiscovery(projectPath, projectId) {\r\n  if (!ToolAutodiscoveryService) {\r\n    console.log(chalk.yellow('âš ï¸  Tool autodiscovery skipped (service not available)'));\r\n    return null;\r\n  }\r\n  \r\n  const toolService = new ToolAutodiscoveryService();\r\n  await toolService.initializeTools();\r\n  \r\n  // Initialize all tools for the project\r\n  const initResult = await toolService.initializeProjectForAllTools(projectPath, projectId);\r\n  \r\n  // Run comprehensive analysis\r\n  const analysisResult = await toolService.analyzeProjectWithAllTools(projectPath, projectId);\r\n  \r\n  // Get tool status summary\r\n  const toolStatuses = await toolService.getToolsStatus(projectId);\r\n  \r\n  initStatus.analyzed.toolAutodiscovery = true;\r\n  initStatus.stats.toolsInitialized = initResult.results?.size || 0;\r\n  initStatus.stats.recordsCreated = initResult.totalRecordsInserted || 0;\r\n  \r\n  return { initResult, analysisResult, toolStatuses };\r\n}\r\n\r\n// Generate comprehensive status report\r\nfunction generateStatusReport() {\r\n  initStatus.endTime = Date.now();\r\n  const duration = initStatus.endTime - initStatus.startTime;\r\n  \r\n  console.log(chalk.bold.cyan('\\\\nðŸ“Š CODEMIND DATABASE INITIALIZATION REPORT'));\r\n  console.log(chalk.cyan('â•'.repeat(60)));\r\n  \r\n  // Connection status\r\n  console.log(chalk.bold.yellow('\\\\nðŸ”— DATABASE CONNECTIONS:'));\r\n  Object.entries(initStatus.connections).forEach(([db, connected]) => {\r\n    const status = connected ? chalk.green('âœ… Connected') : chalk.red('âŒ Failed');\r\n    console.log(`   ${db.padEnd(12)}: ${status}`);\r\n  });\r\n  \r\n  // Initialization status\r\n  console.log(chalk.bold.yellow('\\\\nðŸ—ï¸  INITIALIZATION STATUS:'));\r\n  Object.entries(initStatus.initialized).forEach(([db, initialized]) => {\r\n    const status = initialized ? chalk.green('âœ… Initialized') : chalk.red('âŒ Failed');\r\n    console.log(`   ${db.padEnd(12)}: ${status}`);\r\n  });\r\n  \r\n  // Population status\r\n  console.log(chalk.bold.yellow('\\\\nðŸ“¦ DATA POPULATION:'));\r\n  Object.entries(initStatus.populated).forEach(([db, populated]) => {\r\n    const status = populated ? chalk.green('âœ… Populated') : chalk.red('âŒ Failed');\r\n    console.log(`   ${db.padEnd(12)}: ${status}`);\r\n  });\r\n  \r\n  // Analysis status\r\n  if (Object.keys(initStatus.analyzed).length > 0) {\r\n    console.log(chalk.bold.yellow('\\\\nðŸ§  ANALYSIS STATUS:'));\r\n    Object.entries(initStatus.analyzed).forEach(([analysis, completed]) => {\r\n      const status = completed ? chalk.green('âœ… Completed') : chalk.red('âŒ Failed');\r\n      console.log(`   ${analysis.padEnd(18)}: ${status}`);\r\n    });\r\n  }\r\n  \r\n  // Statistics\r\n  console.log(chalk.bold.yellow('\\\\nðŸ“ˆ STATISTICS:'));\r\n  Object.entries(initStatus.stats).forEach(([key, value]) => {\r\n    console.log(`   ${key.padEnd(25)}: ${chalk.white(value)}`);\r\n  });\r\n  \r\n  // Errors\r\n  if (initStatus.errors.length > 0) {\r\n    console.log(chalk.bold.red('\\\\nâš ï¸  ERRORS:'));\r\n    initStatus.errors.forEach(error => {\r\n      console.log(`   â€¢ ${error}`);\r\n    });\r\n  }\r\n  \r\n  // Summary\r\n  console.log(chalk.cyan('\\\\nâ•'.repeat(60)));\r\n  console.log(chalk.bold.white(`â±ï¸  Total Time: ${Math.round(duration / 1000)}s`));\r\n  \r\n  const successCount = Object.values(initStatus.initialized).filter(Boolean).length;\r\n  const totalDbs = Object.keys(initStatus.connections).length + 1; // +1 for DuckDB\r\n  \r\n  if (successCount === totalDbs && initStatus.errors.length === 0) {\r\n    console.log(chalk.bold.green('ðŸŽ‰ ALL SYSTEMS INITIALIZED SUCCESSFULLY!'));\r\n  } else if (successCount > totalDbs / 2) {\r\n    console.log(chalk.bold.yellow('âš ï¸  PARTIAL SUCCESS - Some components failed'));\r\n  } else {\r\n    console.log(chalk.bold.red('âŒ INITIALIZATION INCOMPLETE'));\r\n  }\r\n  \r\n  console.log(chalk.gray('\\\\nNext steps: npm run dashboard or docker-compose up'));\r\n  console.log(chalk.cyan('â•'.repeat(60)));\r\n}\r\n\r\n// Main execution\r\nasync function main() {\r\n  console.log(chalk.bold.cyan('\\\\nðŸš€ CODEMIND MASTER DATABASE INITIALIZATION\\\\n'));\r\n  \r\n  // Test connections first\r\n  const connections = await testConnections();\r\n  \r\n  console.log(chalk.blue('\\\\nðŸ“¦ Starting comprehensive initialization...\\\\n'));\r\n  \r\n  // Initialize databases that are available\r\n  const tasks = [];\r\n  \r\n  if (connections.postgres) {\r\n    tasks.push(safeExecute('PostgreSQL initialization', () => initializePostgreSQL()));\r\n  }\r\n  \r\n  if (connections.mongodb) {\r\n    tasks.push(safeExecute('MongoDB initialization', () => initializeMongoDB()));\r\n  }\r\n  \r\n  if (connections.neo4j) {\r\n    tasks.push(safeExecute('Neo4j initialization', () => initializeNeo4j()));\r\n  }\r\n  \r\n  if (connections.redis) {\r\n    tasks.push(safeExecute('Redis initialization', () => initializeRedis()));\r\n  }\r\n  \r\n  // Always initialize DuckDB directories\r\n  tasks.push(safeExecute('DuckDB initialization', () => initializeDuckDB()));\r\n  \r\n  // Execute database initialization tasks\r\n  await Promise.all(tasks);\r\n  \r\n  // Run analysis tasks for current project\r\n  const projectPath = process.env.PROJECT_PATH || process.cwd();\r\n  const projectId = process.env.PROJECT_ID || `proj_${Date.now()}`;\r\n  \r\n  console.log(chalk.blue('\\\\nðŸ§  Running advanced analysis...\\\\n'));\r\n  \r\n  // Run semantic analysis\r\n  await safeExecute('Semantic graph analysis', () => runSemanticAnalysis(projectPath, projectId));\r\n  \r\n  // Run tool autodiscovery\r\n  await safeExecute('Tool autodiscovery and analysis', () => runToolAutodiscovery(projectPath, projectId));\r\n  \r\n  // Generate comprehensive report\r\n  generateStatusReport();\r\n}\r\n\r\n// Export for use as module\r\nmodule.exports = { main, testConnections, initStatus };\r\n\r\n// Run if called directly\r\nif (require.main === module) {\r\n  main().catch(error => {\r\n    console.error(chalk.red('\\\\nðŸ’¥ Fatal error during initialization:'));\r\n    console.error(error);\r\n    initStatus.errors.push(`Fatal: ${error.message}`);\r\n    generateStatusReport();\r\n    process.exit(1);\r\n  });\r\n}",
  "hash": "5c2a36d641831ff54359a0e1641d2bdb503da7ad42320b5c5b7a35ed0dce4e0f",
  "lastModified": 1758036122387,
  "language": "JavaScript",
  "exports": [],
  "imports": [],
  "functions": [
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "function",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const"
  ],
  "classes": []
}