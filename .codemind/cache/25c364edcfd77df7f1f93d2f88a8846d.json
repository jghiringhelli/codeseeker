{
  "content": "#!/usr/bin/env node\r\n\r\n/**\r\n * Database Initialization Helper\r\n * Handles initialization of all CodeMind databases\r\n */\r\n\r\nconst { Pool } = require('pg');\r\nconst neo4j = require('neo4j-driver');\r\nconst Redis = require('ioredis');\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst chalk = require('chalk');\r\n\r\n// Configuration\r\nconst config = {\r\n  postgres: {\r\n    host: process.env.DB_HOST || 'localhost',\r\n    port: process.env.DB_PORT || 5432,\r\n    database: process.env.DB_NAME || 'codemind',\r\n    user: process.env.DB_USER || 'codemind',\r\n    password: process.env.DB_PASSWORD || 'codemind123'\r\n  },\r\n  neo4j: {\r\n    uri: process.env.NEO4J_URI || 'bolt://localhost:7687',\r\n    user: process.env.NEO4J_USER || 'neo4j',\r\n    password: process.env.NEO4J_PASSWORD || 'codemind123'\r\n  },\r\n  redis: {\r\n    host: process.env.REDIS_HOST || 'localhost',\r\n    port: process.env.REDIS_PORT || 6379,\r\n    password: process.env.REDIS_PASSWORD || undefined\r\n  }\r\n};\r\n\r\n// Test all database connections\r\nasync function testConnections() {\r\n  const results = {\r\n    postgres: false,\r\n    neo4j: false,\r\n    redis: false\r\n  };\r\n  \r\n  // Test PostgreSQL\r\n  try {\r\n    const pgClient = new Pool(config.postgres);\r\n    await pgClient.query('SELECT 1');\r\n    await pgClient.end();\r\n    results.postgres = true;\r\n  } catch (err) {\r\n    // Connection failed\r\n  }\r\n  \r\n  \r\n  // Test Neo4j\r\n  try {\r\n    const driver = neo4j.driver(\r\n      config.neo4j.uri,\r\n      neo4j.auth.basic(config.neo4j.user, config.neo4j.password)\r\n    );\r\n    const session = driver.session();\r\n    await session.run('RETURN 1');\r\n    await session.close();\r\n    await driver.close();\r\n    results.neo4j = true;\r\n  } catch (err) {\r\n    // Connection failed\r\n  }\r\n  \r\n  // Test Redis with better error handling\r\n  try {\r\n    const redis = new Redis({\r\n      ...config.redis,\r\n      retryDelayOnFailover: 100,\r\n      maxRetriesPerRequest: 3,\r\n      lazyConnect: true,\r\n      connectTimeout: 5000,\r\n      commandTimeout: 3000\r\n    });\r\n    \r\n    await redis.connect();\r\n    await redis.ping();\r\n    await redis.disconnect();\r\n    results.redis = true;\r\n  } catch (err) {\r\n    console.log(`Redis connection failed: ${err.message}`);\r\n    results.redis = false;\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n// Initialize PostgreSQL\r\nasync function initializePostgreSQL() {\r\n  const pgClient = new Pool(config.postgres);\r\n  \r\n  try {\r\n    // Read and execute main schema file\r\n    const schemaPath = path.join(__dirname, '..', '..', 'src', 'database', 'schema.postgres.sql');\r\n    const schema = await fs.readFile(schemaPath, 'utf-8');\r\n    \r\n    // Execute the entire schema as one statement to preserve dollar-quoted strings\r\n    try {\r\n      await pgClient.query(schema);\r\n    } catch (err) {\r\n      if (!err.message.includes('already exists')) {\r\n        throw err;\r\n      }\r\n    }\r\n    \r\n    // Read and execute tool-specific tables schema\r\n    const toolTablesPath = path.join(__dirname, '..', '..', 'src', 'database', 'tool-specific-tables.sql');\r\n    try {\r\n      const toolTablesSchema = await fs.readFile(toolTablesPath, 'utf-8');\r\n      try {\r\n        await pgClient.query(toolTablesSchema);\r\n      } catch (err) {\r\n        if (!err.message.includes('already exists')) {\r\n          console.log(chalk.yellow(`‚ö†Ô∏è  Tool table warning: ${err.message}`));\r\n        }\r\n      }\r\n      console.log(chalk.green('‚úÖ Tool-specific tables loaded'));\r\n    } catch (err) {\r\n      console.log(chalk.yellow(`‚ö†Ô∏è  Tool-specific tables not found: ${err.message}`));\r\n    }\r\n    \r\n    // Insert foundation data (ignore duplicates)\r\n    await pgClient.query(`\r\n      INSERT INTO projects (id, project_name, project_path, status, languages, frameworks, project_type, created_at)\r\n      VALUES \r\n        ('00000000-0000-0000-0000-000000000000', 'Default', '/default', 'active', '{}', '{}', 'unknown', NOW())\r\n      ON CONFLICT (id) DO NOTHING;\r\n    `);\r\n    \r\n    return { success: true };\r\n    \r\n  } finally {\r\n    await pgClient.end();\r\n  }\r\n}\r\n\r\n\r\n// Initialize Neo4j\r\nasync function initializeNeo4j() {\r\n  const driver = neo4j.driver(\r\n    config.neo4j.uri,\r\n    neo4j.auth.basic(config.neo4j.user, config.neo4j.password)\r\n  );\r\n  \r\n  try {\r\n    const session = driver.session();\r\n    \r\n    // Create constraints and indexes (ignore duplicates)\r\n    const queries = [\r\n      'CREATE CONSTRAINT project_id IF NOT EXISTS FOR (p:Project) REQUIRE p.id IS UNIQUE',\r\n      'CREATE CONSTRAINT file_path IF NOT EXISTS FOR (f:File) REQUIRE (f.projectId, f.path) IS UNIQUE',\r\n      'CREATE CONSTRAINT class_name IF NOT EXISTS FOR (c:Class) REQUIRE (c.projectId, c.name) IS UNIQUE',\r\n      'CREATE INDEX project_name IF NOT EXISTS FOR (p:Project) ON (p.name)',\r\n      'CREATE INDEX file_type IF NOT EXISTS FOR (f:File) ON (f.type)'\r\n    ];\r\n    \r\n    for (const query of queries) {\r\n      try {\r\n        await session.run(query);\r\n      } catch (err) {\r\n        if (!err.message.includes('already exists')) {\r\n          throw err;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Create foundation nodes\r\n    await session.run(`\r\n      MERGE (p:Project {id: 'default'})\r\n      SET p.name = 'Default Project',\r\n          p.createdAt = datetime(),\r\n          p.status = 'template'\r\n    `);\r\n    \r\n    await session.close();\r\n    return { success: true };\r\n    \r\n  } finally {\r\n    await driver.close();\r\n  }\r\n}\r\n\r\n// Initialize Redis\r\nasync function initializeRedis() {\r\n  const redis = new Redis({\r\n    ...config.redis,\r\n    retryDelayOnFailover: 100,\r\n    maxRetriesPerRequest: 3,\r\n    lazyConnect: true,\r\n    connectTimeout: 10000,\r\n    commandTimeout: 5000\r\n  });\r\n  \r\n  try {\r\n    await redis.connect();\r\n    \r\n    // Set up key patterns and initial values\r\n    await redis.set('codemind:initialized', new Date().toISOString());\r\n    await redis.hset('codemind:config', {\r\n      version: '2.0.0',\r\n      initialized_at: new Date().toISOString()\r\n    });\r\n    \r\n    // Create initial queues\r\n    await redis.lpush('codemind:queue:analysis', JSON.stringify({\r\n      type: 'init',\r\n      timestamp: new Date().toISOString()\r\n    }));\r\n    await redis.ltrim('codemind:queue:analysis', 0, 0);\r\n    \r\n    return { success: true };\r\n    \r\n  } finally {\r\n    await redis.disconnect();\r\n  }\r\n}\r\n\r\n// Initialize DuckDB directories\r\nasync function initializeDuckDB() {\r\n  const dirs = [\r\n    path.join(process.cwd(), '.codemind'),\r\n    path.join(process.cwd(), '.codemind', 'analytics'),\r\n    path.join(process.cwd(), '.codemind', 'cache')\r\n  ];\r\n  \r\n  for (const dir of dirs) {\r\n    await fs.mkdir(dir, { recursive: true });\r\n  }\r\n  \r\n  return { success: true };\r\n}\r\n\r\n// Main function to initialize all databases\r\nasync function main() {\r\n  console.log(chalk.blue('üóÑÔ∏è  Initializing databases...'));\r\n  \r\n  // Test connections first\r\n  const connections = await testConnections();\r\n  \r\n  // Initialize databases that are available\r\n  const results = {};\r\n  \r\n  if (connections.postgres) {\r\n    try {\r\n      await initializePostgreSQL();\r\n      results.postgres = { success: true };\r\n      console.log(chalk.green('‚úÖ PostgreSQL initialized'));\r\n    } catch (error) {\r\n      results.postgres = { success: false, error: error.message };\r\n      console.log(chalk.red('‚ùå PostgreSQL failed'));\r\n    }\r\n  }\r\n  \r\n  \r\n  if (connections.neo4j) {\r\n    try {\r\n      await initializeNeo4j();\r\n      results.neo4j = { success: true };\r\n      console.log(chalk.green('‚úÖ Neo4j initialized'));\r\n    } catch (error) {\r\n      results.neo4j = { success: false, error: error.message };\r\n      console.log(chalk.red('‚ùå Neo4j failed'));\r\n    }\r\n  }\r\n  \r\n  if (connections.redis) {\r\n    try {\r\n      await initializeRedis();\r\n      results.redis = { success: true };\r\n      console.log(chalk.green('‚úÖ Redis initialized'));\r\n    } catch (error) {\r\n      results.redis = { success: false, error: error.message };\r\n      console.log(chalk.red('‚ùå Redis failed'));\r\n    }\r\n  }\r\n  \r\n  // Always initialize DuckDB directories\r\n  try {\r\n    await initializeDuckDB();\r\n    results.duckdb = { success: true };\r\n    console.log(chalk.green('‚úÖ DuckDB directories created'));\r\n  } catch (error) {\r\n    results.duckdb = { success: false, error: error.message };\r\n    console.log(chalk.red('‚ùå DuckDB failed'));\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\nmodule.exports = {\r\n  main,\r\n  testConnections,\r\n  initializePostgreSQL,\r\n  initializeNeo4j,\r\n  initializeRedis,\r\n  initializeDuckDB\r\n};",
  "hash": "fbca4c65d8754cf2992a20d9981eb8f5f15a2e899693b62df97cdd1825129d6e",
  "lastModified": 1757977735792,
  "language": "JavaScript",
  "exports": [],
  "imports": [],
  "functions": [
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "function",
    "const",
    "function",
    "const",
    "function",
    "const",
    "const"
  ],
  "classes": []
}