{
  "content": "const chalk = require('chalk');\n\n/**\n * Analysis Orchestrator - coordinates multiple analyzers and persisters\n * Follows Open/Closed and Dependency Inversion Principles\n */\nclass AnalysisOrchestrator {\n  constructor() {\n    this.analyzers = new Map();\n    this.persisters = new Map();\n    this.results = {\n      totalRecordsCreated: 0,\n      analyzersRun: 0,\n      errors: [],\n      warnings: []\n    };\n  }\n\n  /**\n   * Register an analyzer (Open/Closed Principle)\n   * @param {string} name Analyzer name\n   * @param {IAnalyzer} analyzer Analyzer instance\n   */\n  registerAnalyzer(name, analyzer) {\n    this.analyzers.set(name, analyzer);\n    console.log(chalk.blue(`üìã Registered analyzer: ${name}`));\n  }\n\n  /**\n   * Register a data persister (Open/Closed Principle)\n   * @param {string} name Persister name\n   * @param {IDataPersister} persister Persister instance\n   */\n  registerPersister(name, persister) {\n    this.persisters.set(name, persister);\n    console.log(chalk.blue(`üíæ Registered persister: ${name}`));\n  }\n\n  /**\n   * Initialize all registered components\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize() {\n    console.log(chalk.blue('üöÄ Initializing Analysis Orchestrator...'));\n    \n    let success = true;\n\n    // Initialize analyzers\n    for (const [name, analyzer] of this.analyzers) {\n      try {\n        const result = await analyzer.initialize();\n        if (!result) {\n          this.results.warnings.push(`Analyzer ${name} initialization failed`);\n          success = false;\n        }\n      } catch (error) {\n        this.results.errors.push({ analyzer: name, phase: 'initialization', error: error.message });\n        success = false;\n      }\n    }\n\n    // Initialize persisters\n    for (const [name, persister] of this.persisters) {\n      try {\n        const result = await persister.initialize();\n        if (!result) {\n          this.results.warnings.push(`Persister ${name} initialization failed`);\n          success = false;\n        }\n      } catch (error) {\n        this.results.errors.push({ persister: name, phase: 'initialization', error: error.message });\n        success = false;\n      }\n    }\n\n    return success;\n  }\n\n  /**\n   * Run comprehensive analysis\n   * @param {Object} config Analysis configuration\n   * @returns {Promise<Object>} Analysis results\n   */\n  async runAnalysis({ projectPath, projectId, projectName, analyzers = null }) {\n    console.log(chalk.blue('üß† Starting comprehensive analysis...'));\n\n    const targetAnalyzers = analyzers ? \n      Array.from(this.analyzers.entries()).filter(([name]) => analyzers.includes(name)) :\n      Array.from(this.analyzers.entries());\n\n    const analysisResults = {};\n\n    for (const [name, analyzer] of targetAnalyzers) {\n      try {\n        console.log(chalk.blue(`üîç Running ${name} analysis...`));\n        \n        const startTime = Date.now();\n        const result = await analyzer.analyze({\n          projectPath,\n          projectId,\n          projectName,\n          maxDepth: 4,\n          includeExtensions: ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.go', '.rs', '.cpp', '.c', '.cs']\n        });\n        const duration = Date.now() - startTime;\n\n        analysisResults[name] = {\n          ...result,\n          duration,\n          success: true\n        };\n\n        this.results.analyzersRun++;\n        console.log(chalk.green(`‚úÖ ${name} analysis completed in ${duration}ms`));\n\n        // Auto-persist if corresponding persister exists\n        await this._autoPersist(name, { projectId, treeData: result });\n\n      } catch (error) {\n        console.log(chalk.red(`‚ùå ${name} analysis failed: ${error.message}`));\n        this.results.errors.push({ analyzer: name, phase: 'analysis', error: error.message });\n        analysisResults[name] = {\n          success: false,\n          error: error.message\n        };\n      }\n    }\n\n    return {\n      results: analysisResults,\n      summary: this.results,\n      totalRecordsCreated: this.results.totalRecordsCreated\n    };\n  }\n\n  /**\n   * Auto-persist analysis results using corresponding persister\n   * @param {string} analyzerName Name of the analyzer\n   * @param {Object} data Data to persist\n   * @private\n   */\n  async _autoPersist(analyzerName, data) {\n    // Map analyzer names to persister names\n    const analyzerToPersisterMap = {\n      'TreeNavigation': 'PostgreSQL',\n      'SemanticGraph': 'Neo4j',\n      'ToolAutoDiscovery': 'MongoDB'\n    };\n\n    const persisterName = analyzerToPersisterMap[analyzerName];\n    if (!persisterName || !this.persisters.has(persisterName)) {\n      console.log(chalk.yellow(`‚ö†Ô∏è No persister found for ${analyzerName} analyzer`));\n      return;\n    }\n\n    const persister = this.persisters.get(persisterName);\n    \n    try {\n      console.log(chalk.blue(`üíæ Persisting ${analyzerName} results...`));\n      \n      const result = await persister.persist(data);\n      if (result.success) {\n        this.results.totalRecordsCreated += result.recordsInserted || 0;\n        console.log(chalk.green(`‚úÖ Persisted ${result.recordsInserted || 0} records from ${analyzerName}`));\n      } else {\n        this.results.warnings.push(`Persistence failed for ${analyzerName}: ${result.error}`);\n      }\n    } catch (error) {\n      console.log(chalk.red(`‚ùå Persistence failed for ${analyzerName}: ${error.message}`));\n      this.results.errors.push({ \n        persister: persisterName, \n        phase: 'persistence', \n        analyzer: analyzerName,\n        error: error.message \n      });\n    }\n  }\n\n  /**\n   * Get comprehensive statistics from all components\n   * @returns {Promise<Object>} Statistics\n   */\n  async getStatistics() {\n    const stats = {\n      analyzers: {},\n      persisters: {},\n      overall: this.results\n    };\n\n    // Get analyzer statistics\n    for (const [name, analyzer] of this.analyzers) {\n      try {\n        stats.analyzers[name] = await analyzer.getStatistics();\n      } catch (error) {\n        stats.analyzers[name] = { error: error.message };\n      }\n    }\n\n    // Get persister statistics (if they have this method)\n    for (const [name, persister] of this.persisters) {\n      try {\n        if (typeof persister.getStatistics === 'function') {\n          stats.persisters[name] = await persister.getStatistics();\n        }\n      } catch (error) {\n        stats.persisters[name] = { error: error.message };\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Cleanup all resources\n   * @returns {Promise<void>}\n   */\n  async cleanup() {\n    console.log(chalk.blue('üßπ Cleaning up Analysis Orchestrator...'));\n\n    // Cleanup analyzers\n    for (const [name, analyzer] of this.analyzers) {\n      try {\n        await analyzer.cleanup();\n      } catch (error) {\n        console.log(chalk.yellow(`‚ö†Ô∏è Cleanup warning for ${name} analyzer: ${error.message}`));\n      }\n    }\n\n    // Cleanup persisters\n    for (const [name, persister] of this.persisters) {\n      try {\n        await persister.cleanup();\n      } catch (error) {\n        console.log(chalk.yellow(`‚ö†Ô∏è Cleanup warning for ${name} persister: ${error.message}`));\n      }\n    }\n\n    console.log(chalk.green('‚úÖ Analysis Orchestrator cleanup complete'));\n  }\n\n  /**\n   * Get results summary\n   * @returns {Object} Results summary\n   */\n  getResultsSummary() {\n    return {\n      ...this.results,\n      analyzersRegistered: this.analyzers.size,\n      persistersRegistered: this.persisters.size,\n      success: this.results.errors.length === 0\n    };\n  }\n}\n\nmodule.exports = { AnalysisOrchestrator };",
  "hash": "f1e20387201755b3f51ea1659def31c26ef6d6ace5fb854c4b16f45a197c0e30",
  "lastModified": 1757706051891,
  "language": "JavaScript",
  "exports": [],
  "imports": [],
  "functions": [
    "const",
    "let",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const",
    "const"
  ],
  "classes": [
    "AnalysisOrchestrator"
  ]
}