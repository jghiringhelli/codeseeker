{
  "content": "#!/usr/bin/env node\r\n\r\n/**\r\n * CodeMind Master Project Initialization Script\r\n * \r\n * This is the single entry point for initializing any CodeMind project.\r\n * It consolidates all initialization functionality including:\r\n * - Database initialization (PostgreSQL, MongoDB, Neo4j, Redis, DuckDB)\r\n * - Project registration and analysis\r\n * - Tool autodiscovery and setup\r\n * - Semantic graph population\r\n * - Dashboard data preparation\r\n * \r\n * Usage:\r\n *   node scripts/init-project-master.js [PROJECT_PATH] [PROJECT_NAME]\r\n *   \r\n * Environment variables:\r\n *   PROJECT_PATH - Path to the project directory (default: current directory)\r\n *   PROJECT_NAME - Name of the project (default: directory name)\r\n *   RESET_PROJECT - Set to 'true' to reinitialize existing project data\r\n */\r\n\r\nconst path = require('path');\r\nconst fs = require('fs').promises;\r\nconst chalk = require('chalk');\r\n\r\n// Import helper modules\r\nconst { main: initializeDatabases, testConnections } = require('./helpers/database-init');\r\nconst { initializeProjectData } = require('./helpers/project-init');\r\nconst { runComprehensiveAnalysis } = require('./helpers/analysis-runner');\r\nconst { validateDashboardData } = require('./helpers/dashboard-validator');\r\n\r\n// Configuration from command line and environment\r\nconst config = {\r\n  projectPath: process.argv[2] || process.env.PROJECT_PATH || process.cwd(),\r\n  projectName: process.argv[3] || process.env.PROJECT_NAME || path.basename(process.cwd()),\r\n  resetProject: process.env.RESET_PROJECT === 'true',\r\n  skipAnalysis: process.env.SKIP_ANALYSIS === 'true',\r\n  verbose: process.env.VERBOSE === 'true'\r\n};\r\n\r\n// Global status tracking\r\nconst masterStatus = {\r\n  startTime: Date.now(),\r\n  phases: {},\r\n  errors: [],\r\n  warnings: [],\r\n  projectId: null,\r\n  databasesReady: false,\r\n  projectRegistered: false,\r\n  analysisComplete: false,\r\n  dashboardReady: false\r\n};\r\n\r\n// Helper functions\r\nfunction logPhase(name, status, details = '') {\r\n  const timestamp = new Date().toISOString();\r\n  const statusIcon = status === 'start' ? 'ðŸ”„' : status === 'success' ? 'âœ…' : status === 'error' ? 'âŒ' : 'âš ï¸';\r\n  \r\n  console.log(chalk.cyan(`[${timestamp}] ${statusIcon} ${name}${details ? ': ' + details : ''}`));\r\n  \r\n  if (!masterStatus.phases[name]) {\r\n    masterStatus.phases[name] = {};\r\n  }\r\n  masterStatus.phases[name][status] = timestamp;\r\n  \r\n  if (status === 'error') {\r\n    masterStatus.errors.push({ phase: name, details, timestamp });\r\n  }\r\n  if (status === 'warning') {\r\n    masterStatus.warnings.push({ phase: name, details, timestamp });\r\n  }\r\n}\r\n\r\nasync function validateProject() {\r\n  logPhase('Project Validation', 'start');\r\n  \r\n  try {\r\n    // Check if project path exists\r\n    const stats = await fs.stat(config.projectPath);\r\n    if (!stats.isDirectory()) {\r\n      throw new Error(`Project path is not a directory: ${config.projectPath}`);\r\n    }\r\n    \r\n    // Check if it's a valid project (has package.json or recognizable structure)\r\n    const projectFiles = await fs.readdir(config.projectPath);\r\n    const hasPackageJson = projectFiles.includes('package.json');\r\n    const hasSourceCode = projectFiles.some(file => \r\n      file.includes('src') || file.includes('lib') || file.endsWith('.js') || file.endsWith('.ts')\r\n    );\r\n    \r\n    if (!hasPackageJson && !hasSourceCode) {\r\n      logPhase('Project Validation', 'warning', 'No package.json or source code detected');\r\n    }\r\n    \r\n    // Get project stats\r\n    const sourceFiles = [];\r\n    async function scanDirectory(dir, depth = 0) {\r\n      if (depth > 5) return; // Limit depth\r\n      \r\n      const items = await fs.readdir(dir);\r\n      for (const item of items) {\r\n        if (item.startsWith('.') || item === 'node_modules' || item === 'dist') continue;\r\n        \r\n        const itemPath = path.join(dir, item);\r\n        const stat = await fs.stat(itemPath);\r\n        \r\n        if (stat.isDirectory()) {\r\n          await scanDirectory(itemPath, depth + 1);\r\n        } else if (/\\.(js|ts|py|java|go|rs|cpp|c)$/.test(item)) {\r\n          sourceFiles.push(itemPath);\r\n        }\r\n      }\r\n    }\r\n    \r\n    await scanDirectory(config.projectPath);\r\n    \r\n    logPhase('Project Validation', 'success', `Found ${sourceFiles.length} source files`);\r\n    \r\n    return {\r\n      isValid: true,\r\n      stats: {\r\n        totalFiles: sourceFiles.length,\r\n        hasPackageJson,\r\n        projectSize: sourceFiles.length > 1000 ? 'large' : sourceFiles.length > 100 ? 'medium' : 'small'\r\n      }\r\n    };\r\n    \r\n  } catch (error) {\r\n    logPhase('Project Validation', 'error', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function initializeDatabasesStep() {\r\n  logPhase('Database Initialization', 'start');\r\n  \r\n  try {\r\n    // Test connections first\r\n    const connections = await testConnections();\r\n    const connectedDbs = Object.values(connections).filter(Boolean).length;\r\n    \r\n    if (!connections.postgres) {\r\n      throw new Error('PostgreSQL is not available. PostgreSQL is required for CodeMind to function.');\r\n    }\r\n    \r\n    if (connectedDbs === 0) {\r\n      throw new Error('No databases are available. Please ensure at least PostgreSQL is running.');\r\n    }\r\n    \r\n    logPhase('Database Initialization', 'info', `${connectedDbs}/4 databases connected`);\r\n    \r\n    // Initialize all connected databases\r\n    await initializeDatabases();\r\n    \r\n    masterStatus.databasesReady = true;\r\n    logPhase('Database Initialization', 'success', `${connectedDbs} databases initialized`);\r\n    \r\n    return { success: true, connectedDbs };\r\n    \r\n  } catch (error) {\r\n    logPhase('Database Initialization', 'error', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function registerProjectStep(projectStats) {\r\n  logPhase('Project Registration', 'start');\r\n  \r\n  try {\r\n    const projectData = await initializeProjectData({\r\n      projectPath: config.projectPath,\r\n      projectName: config.projectName,\r\n      resetProject: config.resetProject,\r\n      projectStats\r\n    });\r\n    \r\n    if (!projectData.projectId) {\r\n      throw new Error('Failed to register project - no project ID returned');\r\n    }\r\n    \r\n    masterStatus.projectId = projectData.projectId;\r\n    masterStatus.projectRegistered = true;\r\n    \r\n    logPhase('Project Registration', 'success', `Project ID: ${projectData.projectId}`);\r\n    \r\n    return projectData;\r\n    \r\n  } catch (error) {\r\n    logPhase('Project Registration', 'error', error.message);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function runAnalysisStep() {\r\n  if (config.skipAnalysis) {\r\n    logPhase('Analysis', 'warning', 'Skipped by user request');\r\n    return { skipped: true };\r\n  }\r\n  \r\n  logPhase('Comprehensive Analysis', 'start');\r\n  \r\n  try {\r\n    const analysisResult = await runComprehensiveAnalysis({\r\n      projectPath: config.projectPath,\r\n      projectId: masterStatus.projectId,\r\n      projectName: config.projectName\r\n    });\r\n    \r\n    masterStatus.analysisComplete = true;\r\n    \r\n    const recordsCreated = analysisResult.totalRecordsCreated || 0;\r\n    logPhase('Comprehensive Analysis', 'success', `${recordsCreated} records created`);\r\n    \r\n    return analysisResult;\r\n    \r\n  } catch (error) {\r\n    logPhase('Comprehensive Analysis', 'error', error.message);\r\n    // Don't throw - analysis failure shouldn't stop the whole process\r\n    return { failed: true, error: error.message };\r\n  }\r\n}\r\n\r\nasync function validateDashboardStep() {\r\n  logPhase('Dashboard Validation', 'start');\r\n  \r\n  try {\r\n    const validation = await validateDashboardData(masterStatus.projectId);\r\n    \r\n    if (validation.isValid) {\r\n      masterStatus.dashboardReady = true;\r\n      logPhase('Dashboard Validation', 'success', `${validation.tablesWithData} tables populated`);\r\n    } else {\r\n      logPhase('Dashboard Validation', 'warning', `${validation.issues.length} issues found`);\r\n    }\r\n    \r\n    return validation;\r\n    \r\n  } catch (error) {\r\n    logPhase('Dashboard Validation', 'error', error.message);\r\n    return { isValid: false, error: error.message };\r\n  }\r\n}\r\n\r\nfunction generateFinalReport(projectStats, analysisResult, dashboardValidation) {\r\n  const duration = Date.now() - masterStatus.startTime;\r\n  \r\n  console.log(chalk.bold.cyan('\\n' + 'â•'.repeat(80)));\r\n  console.log(chalk.bold.cyan('ðŸŽ¯ CODEMIND PROJECT INITIALIZATION REPORT'));\r\n  console.log(chalk.bold.cyan('â•'.repeat(80)));\r\n  \r\n  // Project info\r\n  console.log(chalk.bold.yellow('\\nðŸ“ PROJECT INFORMATION:'));\r\n  console.log(`   Name: ${chalk.white(config.projectName)}`);\r\n  console.log(`   Path: ${chalk.white(config.projectPath)}`);\r\n  console.log(`   ID: ${chalk.white(masterStatus.projectId || 'Not assigned')}`);\r\n  console.log(`   Size: ${chalk.white(projectStats?.projectSize || 'Unknown')} (${projectStats?.totalFiles || 0} files)`);\r\n  \r\n  // Phase status\r\n  console.log(chalk.bold.yellow('\\nâš¡ EXECUTION PHASES:'));\r\n  Object.entries(masterStatus.phases).forEach(([phase, statuses]) => {\r\n    const hasSuccess = statuses.success;\r\n    const hasError = statuses.error;\r\n    const status = hasError ? chalk.red('âŒ FAILED') : hasSuccess ? chalk.green('âœ… SUCCESS') : chalk.yellow('âš ï¸ PARTIAL');\r\n    console.log(`   ${phase.padEnd(25)}: ${status}`);\r\n  });\r\n  \r\n  // Key metrics\r\n  console.log(chalk.bold.yellow('\\nðŸ“Š KEY METRICS:'));\r\n  console.log(`   Databases Ready: ${masterStatus.databasesReady ? chalk.green('Yes') : chalk.red('No')}`);\r\n  console.log(`   Project Registered: ${masterStatus.projectRegistered ? chalk.green('Yes') : chalk.red('No')}`);\r\n  console.log(`   Analysis Complete: ${masterStatus.analysisComplete ? chalk.green('Yes') : chalk.red('No')}`);\r\n  console.log(`   Dashboard Ready: ${masterStatus.dashboardReady ? chalk.green('Yes') : chalk.red('No')}`);\r\n  console.log(`   Total Duration: ${chalk.white(Math.round(duration / 1000))}s`);\r\n  \r\n  // Analysis results\r\n  if (analysisResult && !analysisResult.skipped && !analysisResult.failed) {\r\n    console.log(chalk.bold.yellow('\\nðŸ§  ANALYSIS RESULTS:'));\r\n    console.log(`   Records Created: ${chalk.white(analysisResult.totalRecordsCreated || 0)}`);\r\n    console.log(`   Tools Initialized: ${chalk.white(analysisResult.toolsInitialized || 0)}`);\r\n    if (analysisResult.semanticGraphNodes) {\r\n      console.log(`   Graph Nodes: ${chalk.white(analysisResult.semanticGraphNodes)}`);\r\n    }\r\n  }\r\n  \r\n  // Dashboard validation\r\n  if (dashboardValidation) {\r\n    console.log(chalk.bold.yellow('\\nðŸ“Š DASHBOARD STATUS:'));\r\n    if (dashboardValidation.isValid) {\r\n      console.log(`   Status: ${chalk.green('âœ… Ready')}`);\r\n      console.log(`   Tables with Data: ${chalk.white(dashboardValidation.tablesWithData || 0)}`);\r\n    } else {\r\n      console.log(`   Status: ${chalk.yellow('âš ï¸ Issues Found')}`);\r\n      if (dashboardValidation.issues) {\r\n        dashboardValidation.issues.forEach(issue => {\r\n          console.log(`   â€¢ ${chalk.yellow(issue)}`);\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Errors and warnings\r\n  if (masterStatus.errors.length > 0) {\r\n    console.log(chalk.bold.red('\\nâŒ ERRORS:'));\r\n    masterStatus.errors.forEach(error => {\r\n      console.log(`   [${error.phase}] ${chalk.red(error.details)}`);\r\n    });\r\n  }\r\n  \r\n  if (masterStatus.warnings.length > 0) {\r\n    console.log(chalk.bold.yellow('\\nâš ï¸ WARNINGS:'));\r\n    masterStatus.warnings.forEach(warning => {\r\n      console.log(`   [${warning.phase}] ${chalk.yellow(warning.details)}`);\r\n    });\r\n  }\r\n  \r\n  // Next steps\r\n  console.log(chalk.bold.yellow('\\nðŸš€ NEXT STEPS:'));\r\n  if (masterStatus.dashboardReady) {\r\n    console.log(chalk.green('   âœ… Your project is ready! Start the dashboard:'));\r\n    console.log(chalk.white('      npm run dashboard'));\r\n    console.log(chalk.white('      # or'));\r\n    console.log(chalk.white('      docker-compose up dashboard'));\r\n    console.log(chalk.white('      # then visit: http://localhost:3005'));\r\n  } else if (masterStatus.projectRegistered) {\r\n    console.log(chalk.yellow('   âš ï¸ Project registered but dashboard needs attention'));\r\n    console.log(chalk.white('      Check dashboard logs and retry initialization'));\r\n  } else {\r\n    console.log(chalk.red('   âŒ Initialization incomplete'));\r\n    console.log(chalk.white('      Review errors above and ensure databases are running'));\r\n  }\r\n  \r\n  console.log(chalk.bold.cyan('\\nâ•'.repeat(80)));\r\n  \r\n  // Return overall success status\r\n  return {\r\n    success: masterStatus.dashboardReady,\r\n    projectId: masterStatus.projectId,\r\n    errors: masterStatus.errors,\r\n    warnings: masterStatus.warnings\r\n  };\r\n}\r\n\r\n// Main execution\r\nasync function main() {\r\n  console.log(chalk.bold.cyan('\\nðŸš€ CODEMIND MASTER PROJECT INITIALIZATION'));\r\n  console.log(chalk.bold.cyan('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n'));\r\n  \r\n  console.log(chalk.blue('Configuration:'));\r\n  console.log(chalk.gray(`  Project Path: ${config.projectPath}`));\r\n  console.log(chalk.gray(`  Project Name: ${config.projectName}`));\r\n  console.log(chalk.gray(`  Reset Project: ${config.resetProject}`));\r\n  console.log(chalk.gray(`  Skip Analysis: ${config.skipAnalysis}\\n`));\r\n  \r\n  try {\r\n    // Phase 1: Validate project\r\n    const projectStats = await validateProject();\r\n    \r\n    // Phase 2: Initialize databases\r\n    await initializeDatabasesStep();\r\n    \r\n    // Phase 3: Register project\r\n    const projectData = await registerProjectStep(projectStats.stats);\r\n    \r\n    // Phase 4: Run comprehensive analysis\r\n    const analysisResult = await runAnalysisStep();\r\n    \r\n    // Phase 5: Validate dashboard data\r\n    const dashboardValidation = await validateDashboardStep();\r\n    \r\n    // Generate final report\r\n    const report = generateFinalReport(projectStats.stats, analysisResult, dashboardValidation);\r\n    \r\n    // Exit with appropriate code\r\n    process.exit(report.success ? 0 : 1);\r\n    \r\n  } catch (error) {\r\n    console.error(chalk.bold.red('\\nðŸ’¥ FATAL ERROR:'));\r\n    console.error(chalk.red(error.message));\r\n    if (config.verbose && error.stack) {\r\n      console.error(chalk.gray(error.stack));\r\n    }\r\n    \r\n    masterStatus.errors.push({\r\n      phase: 'Fatal',\r\n      details: error.message,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n    generateFinalReport({}, {}, {});\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Export for testing\r\nmodule.exports = { main, masterStatus, config };\r\n\r\n// Run if called directly\r\nif (require.main === module) {\r\n  main().catch(error => {\r\n    console.error(chalk.bold.red('Unhandled error:'), error);\r\n    process.exit(1);\r\n  });\r\n}",
  "hash": "75c244b8a239f286f3ef27468573afaa157d08f4ae2b7040d7349d61d6a6b59b",
  "lastModified": 1757977735798,
  "language": "JavaScript",
  "exports": [],
  "imports": [],
  "functions": [
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "function",
    "const",
    "function",
    "const",
    "const",
    "function",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "function",
    "const",
    "const",
    "const",
    "const",
    "const"
  ],
  "classes": []
}