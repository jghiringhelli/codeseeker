import { EventEmitter } from 'events';
import { Logger } from '../shared/logger';
import { WorkflowExecution, ConcurrencyConfig, TerminalSession, MultiplexorConfig } from './types';
export declare class WorkflowOrchestrator extends EventEmitter {
    private logger;
    private activeExecutions;
    private roleInstances;
    private terminalSessions;
    private concurrencyConfig;
    private multiplexorConfig;
    private workflowDefinitions;
    constructor(logger: Logger, concurrencyConfig: ConcurrencyConfig, multiplexorConfig: MultiplexorConfig);
    private loadWorkflowDefinitions;
    private initializeRoleInstanceTracking;
    startWorkflow(workItemId: string, workflowId: string, inputs: any, metadata: any): Promise<string>;
    private executeWorkflow;
    private traverseWorkflow;
    private getReadyNodes;
    private canExecuteParallelGroup;
    private getNextNodes;
    private executeNodesInParallel;
    private executeNode;
    private createTerminalSession;
    private executeNodeLogic;
    private shouldBacktrack;
    private initiateBacktrack;
    private evaluateBacktrackRule;
    private executeWorkClassifier;
    private executeTestDesigner;
    private executeImplementationDeveloper;
    private executeSecurityAuditor;
    private executeGenericRole;
    private waitForRoleAvailability;
    private processNodeResult;
    private cleanupTerminalSession;
    private resolveBranchName;
    private buildNodeCommand;
    private createGitBranch;
    private evaluateQualityGates;
    private handleQualityGateFailure;
    private handleBacktrackResolution;
    private resetExecutionToNode;
    private gatherBacktrackContext;
    private handleExecutionError;
    private handleExecutionFailure;
    getExecutionStatus(executionId: string): Promise<WorkflowExecution | null>;
    cancelExecution(executionId: string): Promise<boolean>;
    getActiveExecutions(): Promise<WorkflowExecution[]>;
    getTerminalSessions(): Promise<TerminalSession[]>;
}
//# sourceMappingURL=workflow-orchestrator.d.ts.map