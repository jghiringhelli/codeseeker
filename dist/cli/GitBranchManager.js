"use strict";
/**
 * Git Branch Manager - Real implementation for safe development workflow
 * Creates feature branches, manages commits, and handles rollback scenarios
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitBranchManager = void 0;
const child_process_1 = require("child_process");
const util_1 = require("util");
const logger_1 = require("../utils/logger");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
class GitBranchManager {
    logger = logger_1.Logger.getInstance();
    projectPath;
    constructor(projectPath = process.cwd()) {
        this.projectPath = projectPath;
    }
    /**
     * Create a new feature branch for safe development
     */
    async createFeatureBranch(workflowId, description) {
        try {
            // Sanitize branch name
            const sanitizedDescription = description
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '')
                .replace(/\s+/g, '-')
                .substring(0, 50);
            const branchName = `feature/${workflowId}-${sanitizedDescription}`;
            this.logger.info(`ðŸŒ¿ Creating feature branch: ${branchName}`);
            // Ensure we're in a git repository
            await this.ensureGitRepo();
            // Stash any uncommitted changes
            await this.stashUncommittedChanges();
            // Checkout main/master branch and pull latest
            const mainBranch = await this.getMainBranch();
            await execAsync(`git checkout ${mainBranch}`, { cwd: this.projectPath });
            try {
                await execAsync(`git pull origin ${mainBranch}`, { cwd: this.projectPath });
            }
            catch (error) {
                this.logger.warn('âš ï¸ Could not pull latest changes (no remote or network issue)');
            }
            // Create and checkout feature branch
            await execAsync(`git checkout -b ${branchName}`, { cwd: this.projectPath });
            this.logger.info(`âœ… Feature branch created: ${branchName}`);
            return branchName;
        }
        catch (error) {
            this.logger.error(`âŒ Failed to create feature branch: ${error.message}`);
            throw new Error(`Git branch creation failed: ${error.message}`);
        }
    }
    /**
     * Commit changes with descriptive message
     */
    async commitChanges(message, files) {
        try {
            this.logger.info(`ðŸ“ Committing changes: ${message}`);
            // Add specific files or all changes
            if (files && files.length > 0) {
                for (const file of files) {
                    await execAsync(`git add "${file}"`, { cwd: this.projectPath });
                }
            }
            else {
                await execAsync('git add .', { cwd: this.projectPath });
            }
            // Create commit
            const commitMessage = `${message}\n\nðŸ¤– Generated by CodeMind Workflow\nCo-authored-by: CodeMind <codemind@ai>`;
            await execAsync(`git commit -m "${commitMessage}"`, { cwd: this.projectPath });
            // Get commit details
            const { stdout: hashOutput } = await execAsync('git rev-parse HEAD', { cwd: this.projectPath });
            const hash = hashOutput.trim().substring(0, 7);
            const { stdout: statsOutput } = await execAsync('git diff --stat HEAD~1', { cwd: this.projectPath });
            const filesChanged = (statsOutput.match(/\d+ files? changed/)?.[0].match(/\d+/)?.[0]) || '0';
            this.logger.info(`âœ… Committed changes: ${hash} (${filesChanged} files)`);
            return {
                hash,
                message,
                filesChanged: parseInt(filesChanged)
            };
        }
        catch (error) {
            this.logger.error(`âŒ Failed to commit changes: ${error.message}`);
            throw new Error(`Git commit failed: ${error.message}`);
        }
    }
    /**
     * Commit and merge feature branch to main if quality checks pass
     */
    async commitAndMerge(branchName, finalMessage) {
        try {
            this.logger.info(`ðŸ”€ Merging branch ${branchName} to main`);
            // Final commit on feature branch
            await this.commitChanges(finalMessage);
            // Switch to main branch
            const mainBranch = await this.getMainBranch();
            await execAsync(`git checkout ${mainBranch}`, { cwd: this.projectPath });
            // Merge feature branch (no-ff to preserve history)
            await execAsync(`git merge --no-ff ${branchName} -m "Merge ${branchName}: ${finalMessage}"`, {
                cwd: this.projectPath
            });
            // Clean up feature branch
            await execAsync(`git branch -d ${branchName}`, { cwd: this.projectPath });
            this.logger.info(`âœ… Successfully merged and cleaned up ${branchName}`);
        }
        catch (error) {
            this.logger.error(`âŒ Failed to merge branch: ${error.message}`);
            throw new Error(`Git merge failed: ${error.message}`);
        }
    }
    /**
     * Rollback branch if quality checks fail
     */
    async rollbackBranch(branchName) {
        try {
            this.logger.info(`ðŸ”„ Rolling back branch: ${branchName}`);
            // Switch to main branch
            const mainBranch = await this.getMainBranch();
            await execAsync(`git checkout ${mainBranch}`, { cwd: this.projectPath });
            // Force delete feature branch (lose all changes)
            await execAsync(`git branch -D ${branchName}`, { cwd: this.projectPath });
            // Restore any stashed changes
            try {
                await execAsync('git stash pop', { cwd: this.projectPath });
            }
            catch (error) {
                // No stash to pop, that's fine
            }
            this.logger.info(`âœ… Rolled back and cleaned up ${branchName}`);
        }
        catch (error) {
            this.logger.error(`âŒ Failed to rollback branch: ${error.message}`);
            throw new Error(`Git rollback failed: ${error.message}`);
        }
    }
    /**
     * Get current git status
     */
    async getGitStatus() {
        try {
            const { stdout: branchOutput } = await execAsync('git branch --show-current', { cwd: this.projectPath });
            const branch = branchOutput.trim();
            const { stdout: statusOutput } = await execAsync('git status --porcelain', { cwd: this.projectPath });
            const modified = [];
            const untracked = [];
            const staged = [];
            statusOutput.split('\n').forEach(line => {
                if (!line)
                    return;
                const status = line.substring(0, 2);
                const file = line.substring(3);
                if (status.includes('M'))
                    modified.push(file);
                if (status.includes('?'))
                    untracked.push(file);
                if (status[0] !== ' ' && status[0] !== '?')
                    staged.push(file);
            });
            return {
                branch,
                ahead: 0, // Would implement with git log comparison
                behind: 0,
                modified,
                untracked,
                staged
            };
        }
        catch (error) {
            throw new Error(`Failed to get git status: ${error.message}`);
        }
    }
    // Helper methods
    async ensureGitRepo() {
        try {
            await execAsync('git status', { cwd: this.projectPath });
        }
        catch (error) {
            throw new Error('Not a git repository. Please initialize git first: git init');
        }
    }
    async getMainBranch() {
        try {
            // Try to detect main branch (main, master, develop)
            const { stdout } = await execAsync('git branch -r', { cwd: this.projectPath });
            if (stdout.includes('origin/main'))
                return 'main';
            if (stdout.includes('origin/master'))
                return 'master';
            if (stdout.includes('origin/develop'))
                return 'develop';
            // Fallback to local branches
            const { stdout: localBranches } = await execAsync('git branch', { cwd: this.projectPath });
            if (localBranches.includes('main'))
                return 'main';
            if (localBranches.includes('master'))
                return 'master';
            return 'master'; // Default fallback
        }
        catch (error) {
            return 'master'; // Fallback
        }
    }
    async stashUncommittedChanges() {
        try {
            const { stdout } = await execAsync('git status --porcelain', { cwd: this.projectPath });
            if (stdout.trim()) {
                await execAsync('git stash push -m "CodeMind workflow stash"', { cwd: this.projectPath });
                this.logger.info('ðŸ“¦ Stashed uncommitted changes');
            }
        }
        catch (error) {
            // Ignore stash errors, probably nothing to stash
        }
    }
}
exports.GitBranchManager = GitBranchManager;
exports.default = GitBranchManager;
//# sourceMappingURL=GitBranchManager.js.map