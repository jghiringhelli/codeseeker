"use strict";
/**
 * Phase 4: Development Plan Management API Handlers
 *
 * Handles development plan registration, progress tracking, and management
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlanHandlers = void 0;
const uuid_1 = require("uuid");
class PlanHandlers {
    dbManager;
    logger;
    constructor(dbManager, logger) {
        this.dbManager = dbManager;
        this.logger = logger;
    }
    // ============================================
    // PLAN MANAGEMENT ENDPOINTS
    // ============================================
    /**
     * POST /plans - Register new development plan
     */
    async createPlan(req, res) {
        try {
            const { projectPath, planType, title, description, priority = 'medium', estimatedEffortHours, estimatedDurationDays, assignedTo, tags = [], primaryGoals = [], successCriteria = [], acceptanceCriteria = [], plannedStartDate, plannedEndDate, phases = [], tasks = [], templateId, autoGenerated = false, claudeEnhanced = false, metadata = {} } = req.body;
            // Validation
            if (!projectPath || !planType || !title) {
                res.status(400).json({
                    success: false,
                    error: 'Missing required fields: projectPath, planType, title'
                });
                return;
            }
            // Get or create project
            let project = await this.dbManager.getProject(projectPath);
            if (!project) {
                project = await this.dbManager.createProject({
                    projectPath,
                    projectName: projectPath.split('/').pop() || 'Unknown',
                    projectType: 'unknown',
                    languages: [],
                    frameworks: [],
                    totalFiles: 0,
                    totalLines: 0,
                    status: 'active',
                    metadata: {}
                });
            }
            // Create the development plan
            const planId = (0, uuid_1.v4)();
            const planData = {
                id: planId,
                projectId: project.id,
                planType,
                title,
                description,
                priority,
                status: 'draft',
                estimatedEffortHours,
                estimatedDurationDays,
                assignedTo,
                tags,
                primaryGoals,
                successCriteria,
                acceptanceCriteria,
                plannedStartDate: plannedStartDate ? new Date(plannedStartDate) : undefined,
                plannedEndDate: plannedEndDate ? new Date(plannedEndDate) : undefined,
                templateId,
                autoGenerated,
                claudeEnhanced,
                metadata
            };
            const createdPlan = await this.createPlanInDB(planData);
            // Create phases if provided
            if (phases && phases.length > 0) {
                for (const phase of phases) {
                    await this.createPhaseInDB({
                        planId,
                        phaseName: phase.name,
                        phaseDescription: phase.description,
                        phaseOrder: phase.order,
                        plannedStartDate: phase.plannedStartDate ? new Date(phase.plannedStartDate) : undefined,
                        plannedEndDate: phase.plannedEndDate ? new Date(phase.plannedEndDate) : undefined,
                        metadata: phase.metadata || {}
                    });
                }
            }
            // Create tasks if provided
            if (tasks && tasks.length > 0) {
                for (const task of tasks) {
                    await this.createTaskInDB({
                        planId,
                        phaseId: task.phaseId,
                        title: task.title,
                        description: task.description,
                        taskType: task.taskType || 'development',
                        priority: task.priority || 'medium',
                        status: 'not_started',
                        assignee: task.assignee,
                        reviewer: task.reviewer,
                        estimatedHours: task.estimatedHours || 0,
                        plannedStartDate: task.plannedStartDate ? new Date(task.plannedStartDate) : undefined,
                        plannedEndDate: task.plannedEndDate ? new Date(task.plannedEndDate) : undefined,
                        taskOrder: task.taskOrder,
                        dependencies: task.dependencies || [],
                        metadata: task.metadata || {}
                    });
                }
            }
            // Log progress update
            await this.logProgressUpdate(planId, {
                updateType: 'plan_creation',
                updateSummary: `Development plan '${title}' created`,
                detailedNotes: `Plan type: ${planType}, Priority: ${priority}`,
                updatedBy: req.body.createdBy || 'system',
                updateSource: 'manual'
            });
            this.logger.info('Development plan created successfully', {
                planId,
                projectPath,
                planType,
                title
            });
            res.json({
                success: true,
                data: {
                    planId,
                    title,
                    status: 'draft',
                    projectPath,
                    planType,
                    createdAt: new Date().toISOString(),
                    nextSteps: [
                        'Review and refine plan details',
                        'Update task estimates',
                        'Set realistic timeline',
                        'Assign team members'
                    ]
                }
            });
        }
        catch (error) {
            this.logger.error('Failed to create development plan', error);
            res.status(500).json({
                success: false,
                error: 'Failed to create development plan'
            });
        }
    }
    /**
     * GET /plans/:projectPath - Get development plans for project
     */
    async getProjectPlans(req, res) {
        try {
            const projectPath = `/${req.params.projectPath}`;
            const { status, type, priority, assignedTo, limit = 20, offset = 0, includeArchived = false } = req.query;
            const project = await this.dbManager.getProject(projectPath);
            if (!project) {
                res.status(404).json({
                    success: false,
                    error: 'Project not found'
                });
                return;
            }
            const plans = await this.getPlansFromDB(project.id, {
                status: status,
                planType: type,
                priority: priority,
                assignedTo: assignedTo,
                limit: parseInt(limit),
                offset: parseInt(offset),
                includeArchived: includeArchived === 'true'
            });
            res.json({
                success: true,
                data: {
                    projectPath,
                    plans,
                    totalCount: plans.length,
                    filters: {
                        status, type, priority, assignedTo, includeArchived
                    }
                }
            });
        }
        catch (error) {
            this.logger.error('Failed to get project plans', error);
            res.status(500).json({
                success: false,
                error: 'Failed to get project plans'
            });
        }
    }
    /**
     * GET /plans/details/:planId - Get detailed plan information
     */
    async getPlanDetails(req, res) {
        try {
            const planId = req.params.planId;
            const plan = await this.getPlanFromDB(planId);
            if (!plan) {
                res.status(404).json({
                    success: false,
                    error: 'Plan not found'
                });
                return;
            }
            const phases = await this.getPhasesFromDB(planId);
            const tasks = await this.getTasksFromDB(planId);
            const blockers = await this.getActiveBlockersFromDB(planId);
            const milestones = await this.getMilestonesFromDB(planId);
            const recentProgress = await this.getRecentProgressFromDB(planId, 10);
            res.json({
                success: true,
                data: {
                    plan,
                    phases,
                    tasks,
                    blockers,
                    milestones,
                    recentProgress,
                    summary: {
                        totalTasks: tasks.length,
                        completedTasks: tasks.filter(t => t.status === 'completed').length,
                        blockedTasks: tasks.filter(t => t.status === 'blocked').length,
                        activeBlockers: blockers.length,
                        overallProgress: plan.completionPercentage || 0,
                        timelineStatus: this.calculateTimelineStatus(plan, tasks)
                    }
                }
            });
        }
        catch (error) {
            this.logger.error('Failed to get plan details', error);
            res.status(500).json({
                success: false,
                error: 'Failed to get plan details'
            });
        }
    }
    /**
     * POST /plans/:planId/progress - Update plan progress
     */
    async updatePlanProgress(req, res) {
        try {
            const planId = req.params.planId;
            const progressUpdate = req.body;
            const updatedBy = req.body.updatedBy || 'unknown';
            const plan = await this.getPlanFromDB(planId);
            if (!plan) {
                res.status(404).json({
                    success: false,
                    error: 'Plan not found'
                });
                return;
            }
            const results = {
                tasksUpdated: 0,
                blockersCreated: 0,
                milestonesAchieved: 0,
                progressLogged: false
            };
            // Update individual tasks
            if (progressUpdate.taskUpdates && progressUpdate.taskUpdates.length > 0) {
                for (const taskUpdate of progressUpdate.taskUpdates) {
                    await this.updateTaskInDB(taskUpdate.taskId, taskUpdate);
                    // Log task-specific progress
                    await this.logProgressUpdate(planId, {
                        updateType: 'task_progress',
                        taskId: taskUpdate.taskId,
                        previousStatus: undefined, // Will be filled by trigger
                        newStatus: taskUpdate.status,
                        updateSummary: `Task updated: ${taskUpdate.status}`,
                        detailedNotes: taskUpdate.notes,
                        hoursAdded: taskUpdate.actualHours,
                        updatedBy,
                        updateSource: 'manual',
                        relatedCommits: taskUpdate.relatedCommits || [],
                        relatedFiles: taskUpdate.relatedFiles || []
                    });
                    results.tasksUpdated++;
                }
            }
            // Create new blockers
            if (progressUpdate.blockers && progressUpdate.blockers.length > 0) {
                for (const blocker of progressUpdate.blockers) {
                    await this.createBlockerInDB(planId, blocker);
                    results.blockersCreated++;
                }
            }
            // Record milestone achievements
            if (progressUpdate.milestones && progressUpdate.milestones.length > 0) {
                for (const milestone of progressUpdate.milestones) {
                    await this.recordMilestoneAchievement(planId, milestone);
                    results.milestonesAchieved++;
                }
            }
            // Log general progress update
            if (progressUpdate.generalUpdate) {
                await this.logProgressUpdate(planId, {
                    updateType: 'general',
                    updateSummary: progressUpdate.generalUpdate.summary,
                    detailedNotes: progressUpdate.generalUpdate.notes,
                    hoursAdded: progressUpdate.generalUpdate.hoursSpent,
                    updatedBy,
                    updateSource: 'manual'
                });
                results.progressLogged = true;
            }
            // Get updated plan summary
            const updatedPlan = await this.getPlanFromDB(planId);
            this.logger.info('Plan progress updated successfully', {
                planId,
                updatedBy,
                results
            });
            res.json({
                success: true,
                data: {
                    planId,
                    results,
                    currentProgress: updatedPlan?.completionPercentage || 0,
                    updatedAt: new Date().toISOString(),
                    nextActions: this.generateNextActions(updatedPlan, results)
                }
            });
        }
        catch (error) {
            this.logger.error('Failed to update plan progress', error);
            res.status(500).json({
                success: false,
                error: 'Failed to update plan progress'
            });
        }
    }
    /**
     * GET /plans/:planId/progress - Get progress summary
     */
    async getPlanProgress(req, res) {
        try {
            const planId = req.params.planId;
            const { days = 30 } = req.query;
            const plan = await this.getPlanFromDB(planId);
            if (!plan) {
                res.status(404).json({
                    success: false,
                    error: 'Plan not found'
                });
                return;
            }
            const tasks = await this.getTasksFromDB(planId);
            const blockers = await this.getActiveBlockersFromDB(planId);
            const progressHistory = await this.getProgressHistoryFromDB(planId, parseInt(days));
            const progressSummary = {
                overall: {
                    completionPercentage: plan.completionPercentage || 0,
                    tasksCompleted: plan.completedTasks || 0,
                    tasksTotal: plan.totalTasks || 0,
                    estimatedHoursTotal: plan.estimatedHoursTotal || 0,
                    actualHoursSpent: plan.actualHoursSpent || 0,
                    onTrack: this.isOnTrack(plan, tasks),
                    timelineStatus: this.calculateTimelineStatus(plan, tasks)
                },
                tasks: {
                    byStatus: this.groupTasksByStatus(tasks),
                    byPriority: this.groupTasksByPriority(tasks),
                    overdueTasks: tasks.filter(t => this.isTaskOverdue(t)).length
                },
                blockers: {
                    active: blockers.length,
                    bySeverity: this.groupBlockersBySeverity(blockers),
                    averageResolutionTime: 0 // TODO: Calculate from resolved blockers
                },
                velocity: {
                    tasksCompletedThisWeek: this.getTasksCompletedInPeriod(progressHistory, 7),
                    averageTaskCompletionTime: this.calculateAverageTaskTime(tasks),
                    burndownData: this.generateBurndownData(progressHistory)
                }
            };
            res.json({
                success: true,
                data: {
                    planId,
                    planTitle: plan.title,
                    progress: progressSummary,
                    recentActivity: progressHistory.slice(0, 10),
                    recommendations: this.generateProgressRecommendations(progressSummary, blockers)
                }
            });
        }
        catch (error) {
            this.logger.error('Failed to get plan progress', error);
            res.status(500).json({
                success: false,
                error: 'Failed to get plan progress'
            });
        }
    }
    // ============================================
    // CLAUDE INTEGRATION ENDPOINTS
    // ============================================
    /**
     * POST /plans/:planId/claude-optimize - AI plan optimization
     */
    async claudeOptimizePlan(req, res) {
        try {
            const planId = req.params.planId;
            const { optimizationType, context } = req.body;
            const plan = await this.getPlanFromDB(planId);
            if (!plan) {
                res.status(404).json({
                    success: false,
                    error: 'Plan not found'
                });
                return;
            }
            // This would integrate with Claude API to provide AI insights
            // For now, returning structured recommendations
            const optimization = await this.generateAIOptimization(plan, optimizationType, context);
            res.json({
                success: true,
                data: {
                    planId,
                    optimizationType,
                    recommendations: optimization.recommendations,
                    estimatedImpact: optimization.impact,
                    suggestedChanges: optimization.changes,
                    riskAssessment: optimization.risks
                }
            });
        }
        catch (error) {
            this.logger.error('Failed to optimize plan with Claude', error);
            res.status(500).json({
                success: false,
                error: 'Failed to optimize plan'
            });
        }
    }
    // ============================================
    // HELPER METHODS
    // ============================================
    async createPlanInDB(plan) {
        // Implementation would insert into development_plans table
        // For now returning the plan with generated ID
        return { ...plan, id: plan.id || (0, uuid_1.v4)() };
    }
    async createPhaseInDB(phase) {
        // Implementation would insert into plan_phases table
        return { ...phase, id: (0, uuid_1.v4)() };
    }
    async createTaskInDB(task) {
        // Implementation would insert into plan_tasks table
        return { ...task, id: (0, uuid_1.v4)() };
    }
    async getPlansFromDB(projectId, filters) {
        // Implementation would query development_plans table with filters
        return [];
    }
    async getPlanFromDB(planId) {
        // Implementation would query single plan
        return null;
    }
    async getPhasesFromDB(planId) {
        // Implementation would query plan_phases table
        return [];
    }
    async getTasksFromDB(planId) {
        // Implementation would query plan_tasks table
        return [];
    }
    async updateTaskInDB(taskId, update) {
        // Implementation would update plan_tasks table
    }
    async getActiveBlockersFromDB(planId) {
        // Implementation would query active blockers
        return [];
    }
    async getMilestonesFromDB(planId) {
        // Implementation would query milestones
        return [];
    }
    async getRecentProgressFromDB(planId, limit) {
        // Implementation would query progress history
        return [];
    }
    async getProgressHistoryFromDB(planId, days) {
        // Implementation would query progress history for specified days
        return [];
    }
    async logProgressUpdate(planId, update) {
        // Implementation would insert into plan_progress_history table
    }
    async createBlockerInDB(planId, blocker) {
        // Implementation would insert into task_blockers table
    }
    async recordMilestoneAchievement(planId, milestone) {
        // Implementation would update or insert milestone
    }
    calculateTimelineStatus(plan, tasks) {
        // Implementation would analyze timeline vs progress
        return 'on_track';
    }
    isOnTrack(plan, tasks) {
        // Implementation would analyze if plan is on track
        return true;
    }
    groupTasksByStatus(tasks) {
        return tasks.reduce((acc, task) => {
            acc[task.status] = (acc[task.status] || 0) + 1;
            return acc;
        }, {});
    }
    groupTasksByPriority(tasks) {
        return tasks.reduce((acc, task) => {
            acc[task.priority] = (acc[task.priority] || 0) + 1;
            return acc;
        }, {});
    }
    groupBlockersBySeverity(blockers) {
        return blockers.reduce((acc, blocker) => {
            acc[blocker.severity] = (acc[blocker.severity] || 0) + 1;
            return acc;
        }, {});
    }
    isTaskOverdue(task) {
        return task.plannedEndDate ? new Date(task.plannedEndDate) < new Date() && task.status !== 'completed' : false;
    }
    getTasksCompletedInPeriod(history, days) {
        // Implementation would count tasks completed in period
        return 0;
    }
    calculateAverageTaskTime(tasks) {
        // Implementation would calculate average completion time
        return 0;
    }
    generateBurndownData(history) {
        // Implementation would generate burndown chart data
        return [];
    }
    generateNextActions(plan, results) {
        const actions = [];
        if (results.blockersCreated > 0) {
            actions.push('Review and address new blockers');
        }
        if (results.tasksUpdated > 0) {
            actions.push('Update project timeline based on task progress');
        }
        if (plan.completionPercentage && plan.completionPercentage > 75) {
            actions.push('Prepare for plan completion and review');
        }
        return actions;
    }
    generateProgressRecommendations(progress, blockers) {
        const recommendations = [];
        if (blockers.length > 0) {
            recommendations.push('Address active blockers to maintain timeline');
        }
        if (progress.tasks.overdueTasks > 0) {
            recommendations.push('Review and reschedule overdue tasks');
        }
        if (progress.overall.completionPercentage < 25 && progress.overall.timelineStatus === 'due_soon') {
            recommendations.push('Consider timeline adjustment or resource reallocation');
        }
        return recommendations;
    }
    async generateAIOptimization(plan, type, context) {
        // This would integrate with Claude API for real AI insights
        return {
            recommendations: [
                'Break down large tasks into smaller, more manageable pieces',
                'Identify and address dependency bottlenecks',
                'Consider parallel task execution where possible'
            ],
            impact: 'Could reduce overall timeline by 15-20%',
            changes: [
                'Split Task A into 3 sub-tasks',
                'Reassign Task B to reduce dependency chain'
            ],
            risks: [
                'Increased coordination overhead',
                'Potential for integration issues'
            ]
        };
    }
}
exports.PlanHandlers = PlanHandlers;
//# sourceMappingURL=plan-handlers.js.map